<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProPhoto Editor - Photoshop Clone by Kyros Koh</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c2c2c;
            color: #ffffff;
            overflow: hidden;
            /* Prevent text selection on mobile */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Prevent touch callouts and highlight */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Top Menu Bar */
        .menu-bar {
            background: #3c3c3c;
            padding: 8px 16px;
            border-bottom: 1px solid #555;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .menu-bar .menu-item {
            color: #fff;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .menu-bar .menu-item:hover {
            background: #555;
        }

        .menu-separator {
            width: 1px;
            height: 20px;
            background: #555;
        }

        /* Main Tool Bar */
        .toolbar {
            background: #3c3c3c;
            padding: 8px;
            border-bottom: 1px solid #555;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tool-group {
            display: flex;
            background: #4c4c4c;
            border-radius: 6px;
            padding: 2px;
            gap: 2px;
        }

        .tool-button {
            background: transparent;
            border: none;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            min-width: 36px;
            height: 36px;
        }

        .tool-button:hover {
            background: #555;
        }

        .tool-button.active {
            background: #0078d4;
            box-shadow: 0 0 0 1px #0078d4;
        }

        .tool-separator {
            width: 1px;
            height: 32px;
            background: #666;
            margin: 0 4px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 8px;
        }

        .control-label {
            font-size: 12px;
            color: #ccc;
            min-width: 40px;
        }

        .control-input {
            background: #4c4c4c;
            border: 1px solid #666;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            width: 60px;
        }

        .color-picker {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .slider {
            width: 80px;
            height: 4px;
            border-radius: 2px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #0078d4;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Workspace Area */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Right Panel */
        .side-panel {
            width: 280px;
            background: #3c3c3c;
            border-left: 1px solid #555;
            padding: 12px;
            overflow-y: auto;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #fff;
            border-bottom: 1px solid #555;
            padding-bottom: 4px;
        }

        /* Layers Panel */
        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .layer-item {
            background: #4c4c4c;
            border-radius: 4px;
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .layer-item:hover {
            background: #555;
        }

        .layer-item.active {
            background: #0078d4;
        }

        .layer-preview {
            width: 32px;
            height: 32px;
            background: #666;
            border-radius: 2px;
            border: 1px solid #777;
        }

        .layer-info {
            flex: 1;
        }

        .layer-name {
            font-size: 12px;
            font-weight: 500;
        }

        .layer-type {
            font-size: 10px;
            color: #ccc;
        }

        .layer-controls {
            display: flex;
            gap: 4px;
        }

        .layer-btn {
            background: transparent;
            border: none;
            color: #fff;
            padding: 4px;
            border-radius: 2px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .layer-btn:hover {
            background: #555;
        }

        /* History Panel */
        .history-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .history-item {
            background: #4c4c4c;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .history-item:hover {
            background: #555;
        }

        .history-item.active {
            background: #0078d4;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            position: relative;
            background: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
        }

        .canvas-wrapper {
            position: relative;
            background: #888;
            box-shadow: 0 0 0 1px #999;
            transform-origin: center;
            cursor: crosshair;
            /* Improve touch handling */
            touch-action: none;
            -ms-touch-action: none;
        }

        .canvas-wrapper.pan-mode {
            cursor: grab;
        }

        .canvas-wrapper.pan-mode:active {
            cursor: grabbing;
        }

        canvas {
            /* Improve touch handling on canvas */
            touch-action: none;
            -ms-touch-action: none;
            /* Prevent image drag on mobile */
            -webkit-user-drag: none;
        }

        .checkered {
            background-image: 
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        /* Status Bar */
        .status-bar {
            background: #3c3c3c;
            padding: 4px 16px;
            border-top: 1px solid #555;
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 12px;
            color: #ccc;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Color Palette */
        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            margin-top: 8px;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 2px;
            cursor: pointer;
            border: 1px solid #666;
            transition: transform 0.1s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.active {
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px #0078d4;
        }

        /* File Input */
        .file-input {
            display: none;
        }

        /* Selection Rectangle */
        .selection-rect {
            position: absolute;
            border: 1px dashed #0078d4;
            background: rgba(0, 120, 212, 0.1);
            pointer-events: none;
        }

        /* Tool Settings Panel */
        .tool-settings {
            display: none;
            position: absolute;
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 12px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .tool-settings.visible {
            display: block;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .side-panel {
                width: 200px;
            }
        }

        @media (max-width: 768px) {
            .side-panel {
                width: 150px;
            }
            
            .panel-section {
                margin-bottom: 12px;
            }
            
            .panel-title {
                font-size: 12px;
            }
        }

        /* Mobile Touch Improvements */
        @media (hover: none) and (pointer: coarse) {
            /* Increase touch target sizes for mobile */
            .tool-button {
                min-width: 44px;
                min-height: 44px;
                padding: 10px;
            }
            
            .layer-btn {
                min-width: 44px;
                min-height: 44px;
                padding: 8px;
            }
            
            .dropdown-item {
                padding: 12px 16px;
                min-height: 44px;
            }
            
            .menu-item {
                padding: 8px 12px;
                min-height: 44px;
            }
            
            /* Improve color picker touch target */
            .color-picker {
                width: 48px;
                height: 48px;
            }
            
            /* Better slider touch targets */
            .slider {
                height: 8px;
            }
            
            .slider::-webkit-slider-thumb {
                width: 20px;
                height: 20px;
            }
        }

        /* Icon Styles */
        .icon {
            width: 16px;
            height: 16px;
            display: inline-block;
        }

        .icon svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }

        /* Dropdown Menu Styles */
        .menu-item {
            position: relative;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            min-width: 180px;
            z-index: 1000;
            margin-top: 4px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            padding: 8px 16px;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 13px;
            border-bottom: 1px solid #4c4c4c;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background: #555;
        }

        .dropdown-item.disabled {
            color: #888;
            cursor: not-allowed;
        }

        .dropdown-item.disabled:hover {
            background: transparent;
        }

        .dropdown-divider {
            height: 1px;
            background: #555;
            margin: 4px 0;
        }

        /* About Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .modal-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
        }

        .modal-icon {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #0078d4, #00bcf2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            color: white;
        }

        .modal-title-block h2 {
            font-size: 24px;
            margin: 0;
            color: #fff;
        }

        .modal-title-block p {
            font-size: 14px;
            color: #aaa;
            margin: 4px 0 0 0;
        }

        .modal-body {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .modal-body h3 {
            color: #fff;
            font-size: 16px;
            margin: 16px 0 8px 0;
        }

        .modal-body p {
            margin: 8px 0;
            font-size: 14px;
        }

        .modal-body a {
            color: #0078d4;
            text-decoration: none;
        }

        .modal-body a:hover {
            text-decoration: underline;
        }

        .modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            color: #ccc;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: #555;
            color: #fff;
        }

        .modal-footer {
            display: flex;
            justify-content: center;
            gap: 12px;
        }

        .modal-button {
            background: #0078d4;
            border: none;
            color: #fff;
            padding: 10px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .modal-button:hover {
            background: #005a9e;
        }

        .modal-button.secondary {
            background: #4c4c4c;
        }

        .modal-button.secondary:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Menu Bar -->
        <div class="menu-bar">
            <div class="menu-item" onclick="toggleDropdown('fileMenu')">
                File
                <div class="dropdown-menu" id="fileMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); fileActions('new'); hideAllDropdowns();">New Document</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); fileActions('open'); hideAllDropdowns();">Open Image...</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); exportImage(); hideAllDropdowns();">Save As PNG...</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); saveAsJPEG(); hideAllDropdowns();">Save As JPEG...</div>
                </div>
            </div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="toggleDropdown('editMenu')">
                Edit
                <div class="dropdown-menu" id="editMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); undoAction(); hideAllDropdowns();">Undo (Ctrl+Z)</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); redoAction(); hideAllDropdowns();">Redo (Ctrl+Shift+Z)</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); clearCanvas(); hideAllDropdowns();">Clear Canvas</div>
                </div>
            </div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="toggleDropdown('viewMenu')">
                View
                <div class="dropdown-menu" id="viewMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); toggleGrid(); hideAllDropdowns();">Toggle Grid</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); fitToScreen(); hideAllDropdowns();">Fit to Screen</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); actualSize(); hideAllDropdowns();">Actual Size (100%)</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); zoomIn(); hideAllDropdowns();">Zoom In</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); zoomOut(); hideAllDropdowns();">Zoom Out</div>
                </div>
            </div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="toggleDropdown('filterMenu')">
                Filters
                <div class="dropdown-menu" id="filterMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); applyFilter('brightness'); hideAllDropdowns();">Brightness</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); applyFilter('contrast'); hideAllDropdowns();">Contrast</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); applyFilter('blur'); hideAllDropdowns();">Blur</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); applyFilter('sharpen'); hideAllDropdowns();">Sharpen</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); applyFilter('grayscale'); hideAllDropdowns();">Grayscale</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); invertColors(); hideAllDropdowns();">Invert Colors</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); applySepia(); hideAllDropdowns();">Sepia</div>
                </div>
            </div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="toggleDropdown('layerMenu')">
                Layer
                <div class="dropdown-menu" id="layerMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); addNewLayer(); hideAllDropdowns();">New Layer</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); duplicateCurrentLayer(); hideAllDropdowns();">Duplicate Layer</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); deleteCurrentLayer(); hideAllDropdowns();">Delete Layer</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); mergeDown(); hideAllDropdowns();">Merge Down</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); flattenImage(); hideAllDropdowns();">Flatten Image</div>
                </div>
            </div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="toggleDropdown('helpMenu')">
                Help
                <div class="dropdown-menu" id="helpMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); showAbout(); hideAllDropdowns();">About ProPhoto Editor</div>
                </div>
            </div>
        </div>

        <!-- Main Toolbar -->
        <div class="toolbar">
            <!-- Drawing Tools -->
            <div class="tool-group">
                <button class="tool-button active" id="moveTool" onclick="selectTool('move')" title="Move Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2L8 6h3v4H5l4 4V10h4l-2 2h-2v4H8l-2 2h4l4-4h-3v-4h6l-4-4v-2h2l2-2H8l4-4z"/></svg>
                    </div>
                </button>
                <button class="tool-button" id="marqueeTool" onclick="selectTool('marquee')" title="Rectangular Marquee">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"/></svg>
                    </div>
                </button>
                <button class="tool-button" id="lassoTool" onclick="selectTool('lasso')" title="Lasso Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><path d="M8 2L6 8l4 2L8 12l-4 4 6 2 4-6 2-2L12 8z" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-button" id="magicWandTool" onclick="selectTool('magicWand')" title="Magic Wand">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2L8 6h3l2 2-2 2-2 2h3l2 2-2 2-3 3-3-3-3 3-3-3 3-3-2-2 2-2-2-2 2-2 3 3z" fill="currentColor"/></svg>
                    </div>
                </button>
            </div>

            <div class="tool-group">
                <button class="tool-button" id="brushTool" onclick="selectTool('brush')" title="Brush Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><circle cx="8" cy="8" r="3" fill="currentColor"/><rect x="14" y="14" width="6" height="2" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-button" id="pencilTool" onclick="selectTool('pencil')" title="Pencil Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><rect x="3" y="15" width="8" height="4" fill="currentColor"/><rect x="11" y="13" width="10" height="2" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-button" id="eraserTool" onclick="selectTool('eraser')" title="Eraser Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><path d="M16.24 3.56L15.77 3.09L14.24 4.62L14.71 5.09L16.24 3.56M21.9 2.34L21.66 1.1L20.5 1.1L21.84 2.44L21.9 2.34" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-button" id="sprayTool" onclick="selectTool('spray')" title="Spray Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><circle cx="8" cy="8" r="6" fill="currentColor" opacity="0.3"/><circle cx="8" cy="8" r="2" fill="currentColor"/></svg>
                    </div>
                </button>
            </div>

            <div class="tool-group">
                <button class="tool-button" id="textTool" onclick="selectTool('text')" title="Text Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><text x="12" y="16" text-anchor="middle" font-size="12" fill="currentColor">A</text></svg>
                    </div>
                </button>
                <button class="tool-button" id="fillTool" onclick="selectTool('fill')" title="Fill Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2L4 14h16L12 2zM8 18l-4 6h16l-4-6H8z" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-button" id="cropTool" onclick="selectTool('crop')" title="Crop Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><rect x="4" y="4" width="6" height="6" stroke="currentColor" stroke-width="2" fill="none"/><rect x="14" y="4" width="6" height="6" stroke="currentColor" stroke-width="2" fill="none"/><rect x="4" y="14" width="6" height="6" stroke="currentColor" stroke-width="2" fill="none"/><rect x="14" y="14" width="6" height="6" stroke="currentColor" stroke-width="2" fill="none"/></svg>
                    </div>
                </button>
            </div>

            <div class="tool-separator"></div>

            <!-- Control Groups -->
            <div class="control-group">
                <span class="control-label">Size:</span>
                <input type="range" class="slider" id="sizeSlider" min="1" max="100" value="10" onchange="updateSize()">
                <span id="sizeDisplay">10</span>px
            </div>

            <div class="control-group">
                <span class="control-label">Opacity:</span>
                <input type="range" class="slider" id="opacitySlider" min="1" max="100" value="100" onchange="updateOpacity()">
                <span id="opacityDisplay">100</span>%
            </div>

            <div class="control-group">
                <span class="control-label">Zoom:</span>
                <input type="range" class="slider" id="zoomSlider" min="10" max="500" value="100" onchange="updateZoom()">
                <span id="zoomDisplay">100</span>%
                <button class="tool-button" onclick="fitToScreen()">Fit</button>
                <button class="tool-button" onclick="actualSize()">100%</button>
            </div>

            <div class="control-group">
                <span class="control-label">Primary:</span>
                <input type="color" class="color-picker" id="primaryColor" value="#000000" onchange="updateColor()">
                <span class="control-label">Secondary:</span>
                <input type="color" class="color-picker" id="secondaryColor" value="#ffffff" onchange="updateSecondaryColor()">
            </div>
        </div>

        <!-- Workspace -->
        <div class="workspace">
            <!-- Canvas Container (Left) -->
            <div class="canvas-container" id="canvasContainer">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="mainCanvas" class="checkered"></canvas>
                    <canvas id="gridCanvas" class="grid-overlay"></canvas>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="side-panel">
                <!-- Layers Panel -->
                <div class="panel-section">
                    <div class="panel-title">Layers</div>
                    <div class="layer-list" id="layerList">
                        <div class="layer-item active">
                            <div class="layer-preview checkered"></div>
                            <div class="layer-info">
                                <div class="layer-name">Background</div>
                                <div class="layer-type">Background</div>
                            </div>
                            <div class="layer-controls">
                                <button class="layer-btn" onclick="toggleLayerVisibility(0)">üëÅ</button>
                                <button class="layer-btn" onclick="duplicateLayer(0)">üìã</button>
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 8px;">
                        <button class="tool-button" onclick="addNewLayer()" style="width: 100%;">+ Add Layer</button>
                    </div>
                </div>

                <!-- History Panel -->
                <div class="panel-section">
                    <div class="panel-title">History</div>
                    <div class="history-list" id="historyList">
                        <div class="history-item active">Document Created</div>
                    </div>
                </div>

                <!-- Color Palette -->
                <div class="panel-section">
                    <div class="panel-title">Colors</div>
                    <div class="color-palette" id="colorPalette">
                        <!-- Colors will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Filters -->
                <div class="panel-section">
                    <div class="panel-title">Filters</div>
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <button class="tool-button" onclick="applyFilter('brightness')">Brightness</button>
                        <button class="tool-button" onclick="applyFilter('contrast')">Contrast</button>
                        <button class="tool-button" onclick="applyFilter('blur')">Blur</button>
                        <button class="tool-button" onclick="applyFilter('sharpen')">Sharpen</button>
                        <button class="tool-button" onclick="applyFilter('grayscale')">Grayscale</button>
                        <button class="tool-button" onclick="invertColors()">Invert Colors</button>
                        <button class="tool-button" onclick="applySepia()">Sepia</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">Tool: <span id="currentTool">Move</span></div>
            <div class="status-item">Position: <span id="mousePosition">0, 0</span></div>
            <div class="status-item">Size: <span id="canvasSize">800 √ó 600</span></div>
            <div class="status-item">Zoom: <span id="statusZoom">100%</span></div>
        </div>
    </div>

    <!-- Hidden File Input -->
    <input type="file" class="file-input" id="fileInput" accept="image/*" onchange="loadImage(event)">

    <!-- About Modal -->
    <div class="modal-overlay" id="aboutModal" onclick="closeAboutModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="closeAboutModal()">&times;</button>
            <div class="modal-header">
                <div class="modal-icon">P</div>
                <div class="modal-title-block">
                    <h2>ProPhoto Editor</h2>
                    <p>Version 1.0.0</p>
                </div>
            </div>
            <div class="modal-body">
                <p><strong>A browser-based Photoshop clone</strong> built with HTML5 Canvas, CSS3, and Vanilla JavaScript.</p>
                
                <h3>About This Project</h3>
                <p>ProPhoto Editor brings professional-grade image editing capabilities to the web. Inspired by Adobe Photoshop, this application provides a comprehensive set of drawing tools, filters, and layer management features ‚Äî all running entirely in your browser with zero dependencies.</p>
                
                <h3>Creator</h3>
                <p><strong>Kyros Koh</strong><br>
                Full-stack developer passionate about creating powerful web applications.</p>
                
                <h3>Features</h3>
                <p>‚úì 10 Professional drawing & selection tools<br>
                ‚úì Multi-layer support with opacity control<br>
                ‚úì 7 Image filters and effects<br>
                ‚úì Undo/Redo system (20+ steps)<br>
                ‚úì Export to PNG/JPEG<br>
                ‚úì Completely free and open-source</p>
                
                <h3>Links</h3>
                <p>
                    <a href="https://kyroskoh.github.io/photoshop-clone/" target="_blank">Live Demo</a> ‚Ä¢
                    <a href="https://github.com/kyroskoh/photoshop-clone" target="_blank">GitHub Repository</a>
                </p>
                
                <p style="margin-top: 20px; font-size: 12px; color: #888;">
                    ¬© 2025 Kyros Koh. Licensed under MIT License.
                </p>
            </div>
            <div class="modal-footer">
                <button class="modal-button" onclick="closeAboutModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Global Variables
        let canvas, ctx, gridCanvas, gridCtx;
        let mainCanvas = document.getElementById('mainCanvas');
        let canvasWrapper = document.getElementById('canvasWrapper');
        let isDrawing = false;
        let currentTool = 'move';
        let primaryColor = '#000000';
        let secondaryColor = '#ffffff';
        let brushSize = 10;
        let opacity = 1;
        let zoom = 1;
        let panX = 0, panY = 0;
        let startX, startY, endX, endY;
        let layers = [];
        let currentLayer = 0;
        let history = [];
        let historyStates = [];
        let historyIndex = -1;
        let showGrid = false;
        let magicWandTolerance = 32;
        let selectedArea = null;
        let lastTouchX = 0;
        let lastTouchY = 0;

        // Initialize the editor
        function init() {
            canvas = document.getElementById('mainCanvas');
            gridCanvas = document.getElementById('gridCanvas');
            ctx = canvas.getContext('2d');
            gridCtx = gridCanvas.getContext('2d');
            
            // Set initial canvas size
            canvas.width = 800;
            canvas.height = 600;
            gridCanvas.width = canvas.width;
            gridCanvas.height = canvas.height;
            
            // Initialize layers with white background layer
            const backgroundLayer = createLayerCanvas();
            const bgCtx = backgroundLayer.getContext('2d');
            bgCtx.fillStyle = '#ffffff';
            bgCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            layers.push({
                canvas: backgroundLayer,
                name: 'Background',
                visible: true,
                opacity: 1
            });
            
            // Initialize color palette
            initColorPalette();
            
            // Add event listeners
            addEventListeners();
            
            // Render initial canvas
            renderLayers();
            updateLayerList();
            
            // Save initial state and add to history
            history.push('Document Created');
            historyStates.push(saveCanvasState());
            historyIndex = 0;
            updateHistoryDisplay();
        }

        // Create a new layer canvas
        function createLayerCanvas() {
            const layerCanvas = document.createElement('canvas');
            layerCanvas.width = canvas.width;
            layerCanvas.height = canvas.height;
            const layerCtx = layerCanvas.getContext('2d');
            layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
            return layerCanvas;
        }

        // Initialize color palette
        function initColorPalette() {
            const colors = [
                '#ffffff', '#000000', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff',
                '#800000', '#808000', '#008000', '#800080', '#008080', '#808080', '#ffa500', '#ffc0cb',
                '#a52a2a', '#f5deb3', '#90ee90', '#ffb6c1', '#20b2aa', '#87ceeb', '#dda0dd', '#98fb98',
                '#f0e68c', '#cd853f', '#40e0d0', '#ee82ee', '#ff6347', '#ffe4b5', '#d8bfd8', '#1e90ff'
            ];
            
            const palette = document.getElementById('colorPalette');
            colors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.onclick = () => setColor(color);
                palette.appendChild(swatch);
            });
        }

        // Add event listeners
        function addEventListeners() {
            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            
            // Touch events for mobile support
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);
            
            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyDown);
            
            // Prevent context menu
            canvas.addEventListener('contextmenu', e => e.preventDefault());
        }
        
        // Get coordinates from mouse or touch event
        function getEventCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            
            if (e.touches && e.touches.length > 0) {
                // Touch event
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                // Mouse event
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            
            return { x, y };
        }

        // Handle pointer down (mouse or touch start)
        function handlePointerDown(e, x, y) {
            startX = x;
            startY = y;
            isDrawing = true;
            
            if (currentTool === 'brush' || currentTool === 'pencil' || currentTool === 'eraser' || currentTool === 'spray') {
                useBrush(x, y, false);
            } else if (currentTool === 'marquee') {
                startMarquee(x, y);
            } else if (currentTool === 'lasso') {
                startLasso(x, y);
            } else if (currentTool === 'magicWand') {
                selectMagicWand(x, y);
            } else if (currentTool === 'text') {
                showTextDialog(x, y);
            } else if (currentTool === 'fill') {
                floodFill(x, y, primaryColor);
            } else if (currentTool === 'crop') {
                startCrop(x, y);
            } else if (currentTool === 'move') {
                startPan(e);
            }
        }

        // Handle pointer move (mouse or touch move)
        function handlePointerMove(e, x, y) {
            // Update position display
            document.getElementById('mousePosition').textContent = `${Math.round(x)}, ${Math.round(y)}`;
            
            if (!isDrawing) return;
            
            endX = x;
            endY = y;
            
            if (currentTool === 'brush' || currentTool === 'pencil' || currentTool === 'eraser' || currentTool === 'spray') {
                useBrush(x, y, true);
            } else if (currentTool === 'marquee') {
                updateMarquee(x, y);
            } else if (currentTool === 'lasso') {
                updateLasso(x, y);
            } else if (currentTool === 'crop') {
                updateCrop(x, y);
            } else if (currentTool === 'move') {
                panCanvas(e);
            }
        }

        // Handle pointer up (mouse or touch end)
        function handlePointerUp() {
            if (isDrawing) {
                isDrawing = false;
                
                if (currentTool === 'marquee') {
                    endMarquee();
                } else if (currentTool === 'lasso') {
                    endLasso();
                } else if (currentTool === 'crop') {
                    endCrop();
                }
                
                // Add to history
                addToHistory(`Used ${currentTool} tool`);
            }
        }

        // Handle mouse down events
        function handleMouseDown(e) {
            const { x, y } = getEventCoordinates(e);
            handlePointerDown(e, x, y);
        }

        // Handle mouse move events
        function handleMouseMove(e) {
            const { x, y } = getEventCoordinates(e);
            handlePointerMove(e, x, y);
        }

        // Handle mouse up events
        function handleMouseUp(e) {
            handlePointerUp();
        }

        // Handle touch start events
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                e.preventDefault(); // Prevent scrolling and zooming
                const { x, y } = getEventCoordinates(e);
                handlePointerDown(e, x, y);
            }
        }

        // Handle touch move events
        function handleTouchMove(e) {
            if (e.touches.length === 1) {
                e.preventDefault(); // Prevent scrolling
                if (isDrawing) {
                    const { x, y } = getEventCoordinates(e);
                    handlePointerMove(e, x, y);
                }
            }
        }

        // Handle touch end events
        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                handlePointerUp();
                // Reset touch tracking for pan
                lastTouchX = 0;
                lastTouchY = 0;
            }
        }

        // Select tool
        function selectTool(tool) {
            currentTool = tool;
            
            // Update tool buttons
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');
            
            // Update cursor
            if (tool === 'move') {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'crosshair';
            }
            
            // Update status
            document.getElementById('currentTool').textContent = tool.charAt(0).toUpperCase() + tool.slice(1);
        }

        // Use brush/pencil/eraser/spray
        function useBrush(x, y, isDrawing) {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            
            layerCtx.globalAlpha = opacity;
            
            if (currentTool === 'eraser') {
                layerCtx.globalCompositeOperation = 'destination-out';
                layerCtx.strokeStyle = 'rgba(0,0,0,1)';
            } else {
                layerCtx.globalCompositeOperation = 'source-over';
                layerCtx.strokeStyle = primaryColor;
            }
            
            layerCtx.lineCap = 'round';
            layerCtx.lineJoin = 'round';
            layerCtx.lineWidth = brushSize;
            
            if (!isDrawing) {
                layerCtx.beginPath();
                layerCtx.moveTo(x, y);
                layerCtx.lineTo(x + 0.1, y + 0.1);
                layerCtx.stroke();
            } else {
                if (!layerCtx._isDrawing) {
                    layerCtx.beginPath();
                    layerCtx.moveTo(layerCtx._lastX || x, layerCtx._lastY || y);
                }
                layerCtx.lineTo(x, y);
                layerCtx.stroke();
            }
            
            layerCtx._isDrawing = isDrawing;
            layerCtx._lastX = x;
            layerCtx._lastY = y;
            
            renderLayers();
        }

        // Selection tools
        function startMarquee(x, y) {
            selectedArea = {x1: x, y1: y, x2: x, y2: y};
            updateSelectionDisplay();
        }

        function updateMarquee(x, y) {
            selectedArea.x2 = x;
            selectedArea.y2 = y;
            updateSelectionDisplay();
        }

        function endMarquee() {
            // Keep selection area for later use
            updateSelectionDisplay();
        }

        // Magic Wand selection
        function selectMagicWand(x, y) {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            const imageData = layerCtx.getImageData(x, y, 1, 1);
            const targetColor = imageData.data;
            
            const data = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
            const visited = new Set();
            const stack = [[x, y]];
            
            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                const key = `${cx},${cy}`;
                
                if (visited.has(key) || cx < 0 || cy < 0 || cx >= layer.canvas.width || cy >= layer.canvas.height) {
                    continue;
                }
                
                const pixel = data.data[(cy * layer.canvas.width + cx) * 4];
                const pr = data.data[(cy * layer.canvas.width + cx) * 4 + 1];
                const pg = data.data[(cy * layer.canvas.width + cx) * 4 + 2];
                const pb = data.data[(cy * layer.canvas.width + cx) * 4 + 3];
                
                const r = Math.abs(pixel - targetColor[0]);
                const g = Math.abs(pr - targetColor[1]);
                const b = Math.abs(pg - targetColor[2]);
                const a = Math.abs(pb - targetColor[3]);
                
                if (r + g + b + a > magicWandTolerance) continue;
                
                visited.add(key);
                stack.push([cx - 1, cy], [cx + 1, cy], [cx, cy - 1], [cx, cy + 1]);
            }
            
            // Create selection mask
            selectedArea = Array.from(visited).map(key => {
                const [x, y] = key.split(',').map(Number);
                return {x, y};
            });
            
            addToHistory('Magic Wand Selection');
        }

        // Flood fill
        function floodFill(startX, startY, fillColor) {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            const data = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
            
            const targetColor = getPixelColor(data, startX, startY);
            const hex = hexToRgb(fillColor);
            
            const visited = new Set();
            const stack = [[startX, startY]];
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key) || x < 0 || y < 0 || x >= layer.canvas.width || y >= layer.canvas.height) {
                    continue;
                }
                
                const currentColor = getPixelColor(data, x, y);
                
                if (colorsMatch(currentColor, targetColor)) {
                    setPixelColor(data, x, y, hex);
                    visited.add(key);
                    stack.push([x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]);
                }
            }
            
            layerCtx.putImageData(data, 0, 0);
            renderLayers();
        }

        // Text tool
        function showTextDialog(x, y) {
            const text = prompt('Enter text:');
            if (text) {
                const layer = layers[currentLayer];
                const layerCtx = layer.canvas.getContext('2d');
                
                layerCtx.globalAlpha = opacity;
                layerCtx.fillStyle = primaryColor;
                layerCtx.font = `${brushSize * 2}px Arial`;
                layerCtx.fillText(text, x, y);
                
                renderLayers();
                addToHistory('Text Added');
            }
        }

        // Render all layers
        function renderLayers() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            layers.forEach((layer, index) => {
                if (layer.visible) {
                    ctx.save();
                    ctx.globalAlpha = layer.opacity;
                    ctx.drawImage(layer.canvas, 0, 0);
                    ctx.restore();
                }
            });
            
            updateCanvasSize();
        }

        // Update canvas size
        function updateCanvasSize() {
            document.getElementById('canvasSize').textContent = `${canvas.width} √ó ${canvas.height}`;
            
            // Update grid canvas
            gridCanvas.width = canvas.width;
            gridCanvas.height = canvas.height;
        }

        // Save canvas state
        function saveCanvasState() {
            const state = {
                layers: layers.map(layer => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = layer.canvas.width;
                    tempCanvas.height = layer.canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(layer.canvas, 0, 0);
                    return {
                        imageData: tempCanvas.toDataURL(),
                        name: layer.name,
                        visible: layer.visible,
                        opacity: layer.opacity
                    };
                }),
                currentLayer: currentLayer
            };
            return state;
        }

        // Add to history
        function addToHistory(action) {
            // Remove future history if we're not at the end
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
                historyStates = historyStates.slice(0, historyIndex + 1);
            }
            
            // Save current state
            history.push(action);
            historyStates.push(saveCanvasState());
            historyIndex = history.length - 1;
            
            // Limit history to 20 items
            if (history.length > 20) {
                history.shift();
                historyStates.shift();
                historyIndex--;
            }
            
            updateHistoryDisplay();
        }

        // Update history display
        function updateHistoryDisplay() {
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';
            
            history.forEach((action, index) => {
                const item = document.createElement('div');
                item.className = 'history-item' + (index === historyIndex ? ' active' : '');
                item.textContent = action;
                item.onclick = () => restoreFromHistory(index);
                historyList.appendChild(item);
            });
        }

        // Restore from history
        function restoreFromHistory(index) {
            if (index >= 0 && index < historyStates.length) {
                historyIndex = index;
                const state = historyStates[index];
                
                // Restore layers
                layers = [];
                let loadedLayers = 0;
                const totalLayers = state.layers.length;
                
                state.layers.forEach((layerData, i) => {
                    const img = new Image();
                    img.onload = function() {
                        const newLayer = {
                            canvas: createLayerCanvas(),
                            name: layerData.name,
                            visible: layerData.visible,
                            opacity: layerData.opacity
                        };
                        
                        const layerCtx = newLayer.canvas.getContext('2d');
                        layerCtx.drawImage(img, 0, 0);
                        layers[i] = newLayer;
                        
                        loadedLayers++;
                        if (loadedLayers === totalLayers) {
                            currentLayer = state.currentLayer;
                            updateLayerList();
                            renderLayers();
                        }
                    };
                    img.src = layerData.imageData;
                });
                
                updateHistoryDisplay();
            }
        }

        // Undo action
        function undoAction() {
            if (historyIndex > 0) {
                restoreFromHistory(historyIndex - 1);
            }
        }

        // Redo action
        function redoAction() {
            if (historyIndex < history.length - 1) {
                restoreFromHistory(historyIndex + 1);
            }
        }

        // Layer management
        function addNewLayer() {
            const newLayer = {
                canvas: createLayerCanvas(),
                name: `Layer ${layers.length + 1}`,
                visible: true,
                opacity: 1
            };
            
            layers.push(newLayer);
            currentLayer = layers.length - 1;
            
            updateLayerList();
            addToHistory('Layer Added');
        }

        function updateLayerList() {
            const layerList = document.getElementById('layerList');
            layerList.innerHTML = '';
            
            layers.forEach((layer, index) => {
                const item = document.createElement('div');
                item.className = 'layer-item' + (index === currentLayer ? ' active' : '');
                
                item.innerHTML = `
                    <div class="layer-preview checkered"></div>
                    <div class="layer-info">
                        <div class="layer-name">${layer.name}</div>
                        <div class="layer-type">${layer.opacity < 1 ? `${Math.round(layer.opacity * 100)}% opacity` : 'Normal'}</div>
                    </div>
                    <div class="layer-controls">
                        <button class="layer-btn" onclick="toggleLayerVisibility(${index})">${layer.visible ? 'üëÅ' : 'üö´'}</button>
                        <button class="layer-btn" onclick="deleteLayer(${index})">üóë</button>
                    </div>
                `;
                
                item.onclick = () => selectLayer(index);
                layerList.appendChild(item);
            });
        }

        function selectLayer(index) {
            currentLayer = index;
            updateLayerList();
        }

        function toggleLayerVisibility(index) {
            layers[index].visible = !layers[index].visible;
            updateLayerList();
            renderLayers();
        }

        function deleteLayer(index) {
            if (layers.length > 1) {
                layers.splice(index, 1);
                if (currentLayer >= index) {
                    currentLayer = Math.max(0, currentLayer - 1);
                }
                updateLayerList();
                renderLayers();
                addToHistory('Layer Deleted');
            }
        }

        // Zoom and Pan
        function updateZoom() {
            const slider = document.getElementById('zoomSlider');
            zoom = slider.value / 100;
            
            document.getElementById('zoomDisplay').textContent = slider.value;
            document.getElementById('statusZoom').textContent = slider.value + '%';
            
            canvasWrapper.style.transform = `scale(${zoom})`;
        }

        function panCanvas(e) {
            let deltaX = 0;
            let deltaY = 0;
            
            if (e.touches && e.touches.length > 0) {
                // Touch event - calculate delta from last position
                const touch = e.touches[0];
                if (lastTouchX !== 0 || lastTouchY !== 0) {
                    deltaX = touch.clientX - lastTouchX;
                    deltaY = touch.clientY - lastTouchY;
                }
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            } else if (e.buttons === 1) {
                // Mouse event
                deltaX = e.movementX;
                deltaY = e.movementY;
            }
            
            if (deltaX !== 0 || deltaY !== 0) {
                panX += deltaX;
                panY += deltaY;
                canvasWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            }
        }

        function startPan(e) {
            panX = 0;
            panY = 0;
            if (e.touches && e.touches.length > 0) {
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else {
                lastTouchX = 0;
                lastTouchY = 0;
            }
        }

        function fitToScreen() {
            const container = document.getElementById('canvasContainer');
            const scaleX = (container.clientWidth - 40) / canvas.width;
            const scaleY = (container.clientHeight - 40) / canvas.height;
            const newZoom = Math.min(scaleX, scaleY, 1);
            
            document.getElementById('zoomSlider').value = newZoom * 100;
            updateZoom();
        }

        function actualSize() {
            document.getElementById('zoomSlider').value = 100;
            updateZoom();
        }

        // Color functions
        function updateColor() {
            primaryColor = document.getElementById('primaryColor').value;
        }

        function updateSecondaryColor() {
            secondaryColor = document.getElementById('secondaryColor').value;
        }

        function setColor(color) {
            primaryColor = color;
            document.getElementById('primaryColor').value = color;
            
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.classList.remove('active');
                if (swatch.style.backgroundColor === color || swatch.style.backgroundColor === `rgb(${hexToRgb(color).r}, ${hexToRgb(color).g}, ${hexToRgb(color).b})`) {
                    swatch.classList.add('active');
                }
            });
        }

        // Size and opacity controls
        function updateSize() {
            const slider = document.getElementById('sizeSlider');
            brushSize = parseInt(slider.value);
            document.getElementById('sizeDisplay').textContent = slider.value;
        }

        function updateOpacity() {
            const slider = document.getElementById('opacitySlider');
            opacity = slider.value / 100;
            document.getElementById('opacityDisplay').textContent = slider.value;
        }

        // Grid toggle
        function toggleGrid() {
            showGrid = !showGrid;
            if (showGrid) {
                drawGrid();
            } else {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            }
        }

        function drawGrid() {
            const step = 20;
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            gridCtx.strokeStyle = '#333';
            gridCtx.lineWidth = 0.5;
            
            for (let x = 0; x <= gridCanvas.width; x += step) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, gridCanvas.height);
                gridCtx.stroke();
            }
            
            for (let y = 0; y <= gridCanvas.height; y += step) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(gridCanvas.width, y);
                gridCtx.stroke();
            }
            
            gridCtx.strokeStyle = '#666';
            gridCtx.lineWidth = 1;
            
            for (let x = 0; x <= gridCanvas.width; x += step * 5) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, gridCanvas.height);
                gridCtx.stroke();
            }
            
            for (let y = 0; y <= gridCanvas.height; y += step * 5) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(gridCanvas.width, y);
                gridCtx.stroke();
            }
        }

        // Filters
        function applyFilter(type) {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            const imageData = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
            const data = imageData.data;
            
            switch (type) {
                case 'brightness':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] + 20);
                        data[i + 1] = Math.min(255, data[i + 1] + 20);
                        data[i + 2] = Math.min(255, data[i + 2] + 20);
                    }
                    break;
                    
                case 'contrast':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.max(0, Math.min(255, (data[i] - 128) * 1.2 + 128));
                        data[i + 1] = Math.max(0, Math.min(255, (data[i + 1] - 128) * 1.2 + 128));
                        data[i + 2] = Math.max(0, Math.min(255, (data[i + 2] - 128) * 1.2 + 128));
                    }
                    break;
                    
                case 'grayscale':
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        data[i] = data[i + 1] = data[i + 2] = gray;
                    }
                    break;
                    
                case 'sharpen':
                    // Simple sharpening kernel
                    const width = layer.canvas.width;
                    const height = layer.canvas.height;
                    const tempData = new Uint8ClampedArray(data);
                    
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const idx = (y * width + x) * 4;
                            
                            for (let c = 0; c < 3; c++) {
                                let sum = 0;
                                sum += tempData[idx - 4] * -1; // left
                                sum += tempData[idx + 4] * -1; // right
                                sum += tempData[idx - width * 4] * -1; // up
                                sum += tempData[idx + width * 4] * -1; // down
                                sum += tempData[idx] * 5; // center
                                
                                data[idx + c] = Math.max(0, Math.min(255, sum));
                            }
                        }
                    }
                    break;
                    
                case 'blur':
                    // Simple blur with box blur
                    const blurData = new Uint8ClampedArray(data);
                    const blurWidth = layer.canvas.width;
                    const blurHeight = layer.canvas.height;
                    
                    for (let y = 1; y < blurHeight - 1; y++) {
                        for (let x = 1; x < blurWidth - 1; x++) {
                            const idx = (y * blurWidth + x) * 4;
                            
                            for (let c = 0; c < 3; c++) {
                                let sum = 0;
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        sum += blurData[((y + dy) * blurWidth + (x + dx)) * 4 + c];
                                    }
                                }
                                data[idx + c] = sum / 9;
                            }
                            data[idx + 3] = blurData[idx + 3]; // Alpha channel
                        }
                    }
                    break;
            }
            
            layerCtx.putImageData(imageData, 0, 0);
            renderLayers();
            addToHistory(`Applied ${type} filter`);
        }

        // File operations
        function fileActions(action) {
            if (action === 'new') {
                // Create new document
                canvas.width = 800;
                canvas.height = 600;
                gridCanvas.width = canvas.width;
                gridCanvas.height = canvas.height;
                
                // Create white background layer
                const backgroundLayer = createLayerCanvas();
                const bgCtx = backgroundLayer.getContext('2d');
                bgCtx.fillStyle = '#ffffff';
                bgCtx.fillRect(0, 0, canvas.width, canvas.height);
                
                layers = [{
                    canvas: backgroundLayer,
                    name: 'Background',
                    visible: true,
                    opacity: 1
                }];
                
                currentLayer = 0;
                history = [];
                historyStates = [];
                historyIndex = -1;
                
                addToHistory('New Document');
                updateLayerList();
                renderLayers();
            } else if (action === 'open') {
                document.getElementById('fileInput').click();
            }
        }

        function loadImage(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // Resize canvas to image size
                        canvas.width = img.width;
                        canvas.height = img.height;
                        gridCanvas.width = canvas.width;
                        gridCanvas.height = canvas.height;
                        
                        // Clear layers and add image
                        layers = [{
                            canvas: createLayerCanvas(),
                            name: 'Imported Image',
                            visible: true,
                            opacity: 1
                        }];
                        
                        const layerCtx = layers[0].canvas.getContext('2d');
                        layerCtx.drawImage(img, 0, 0);
                        
                        currentLayer = 0;
                        history = [];
                        historyStates = [];
                        historyIndex = -1;
                        
                        addToHistory('Image Loaded');
                        updateLayerList();
                        renderLayers();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function exportImage() {
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');
            
            // Render all visible layers
            layers.forEach(layer => {
                if (layer.visible) {
                    exportCtx.globalAlpha = layer.opacity;
                    exportCtx.drawImage(layer.canvas, 0, 0);
                }
            });
            
            exportCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'exported_image.png';
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        function saveAsPNG() {
            const link = document.createElement('a');
            link.download = 'image.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function saveAsJPEG() {
            const link = document.createElement('a');
            link.download = 'image.jpg';
            link.href = canvas.toDataURL('image/jpeg', 0.9);
            link.click();
        }

        // Keyboard shortcuts
        function handleKeyDown(e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            redoAction();
                        } else {
                            undoAction();
                        }
                        break;
                    case 's':
                        e.preventDefault();
                        exportImage();
                        break;
                    case 'o':
                        e.preventDefault();
                        fileActions('open');
                        break;
                    case 'n':
                        e.preventDefault();
                        fileActions('new');
                        break;
                }
            }
        }

        // Utility functions
        function getPixelColor(data, x, y) {
            const i = (y * data.width + x) * 4;
            return [data.data[i], data.data[i + 1], data.data[i + 2], data.data[i + 3]];
        }

        function setPixelColor(data, x, y, color) {
            const i = (y * data.width + x) * 4;
            data.data[i] = color.r;
            data.data[i + 1] = color.g;
            data.data[i + 2] = color.b;
            data.data[i + 3] = 255;
        }

        function colorsMatch(color1, color2, tolerance = 0) {
            return Math.abs(color1[0] - color2[0]) <= tolerance &&
                   Math.abs(color1[1] - color2[1]) <= tolerance &&
                   Math.abs(color1[2] - color2[2]) <= tolerance &&
                   Math.abs(color1[3] - color2[3]) <= tolerance;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Selection display
        function updateSelectionDisplay() {
            if (selectedArea) {
                // This would draw selection outlines
                // For now, just update the status
            }
        }

        // Dropdown menu functions
        function toggleDropdown(menuId) {
            const menu = document.getElementById(menuId);
            const isShown = menu.classList.contains('show');
            
            // Hide all dropdowns first
            hideAllDropdowns();
            
            // Toggle the clicked menu
            if (!isShown) {
                menu.classList.add('show');
            }
        }

        function hideAllDropdowns() {
            document.querySelectorAll('.dropdown-menu').forEach(menu => {
                menu.classList.remove('show');
            });
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.menu-item')) {
                hideAllDropdowns();
            }
        });

        // Additional menu functions
        function clearCanvas() {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            layerCtx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
            renderLayers();
            addToHistory('Canvas Cleared');
        }

        function zoomIn() {
            const slider = document.getElementById('zoomSlider');
            const newValue = Math.min(500, parseInt(slider.value) + 10);
            slider.value = newValue;
            updateZoom();
        }

        function zoomOut() {
            const slider = document.getElementById('zoomSlider');
            const newValue = Math.max(10, parseInt(slider.value) - 10);
            slider.value = newValue;
            updateZoom();
        }

        function invertColors() {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            const imageData = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];         // Red
                data[i + 1] = 255 - data[i + 1]; // Green
                data[i + 2] = 255 - data[i + 2]; // Blue
            }
            
            layerCtx.putImageData(imageData, 0, 0);
            renderLayers();
            addToHistory('Inverted Colors');
        }

        function applySepia() {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            const imageData = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
            }
            
            layerCtx.putImageData(imageData, 0, 0);
            renderLayers();
            addToHistory('Applied Sepia');
        }

        function duplicateCurrentLayer() {
            if (layers.length > 0) {
                const currentLayerData = layers[currentLayer];
                const newLayer = {
                    canvas: createLayerCanvas(),
                    name: `${currentLayerData.name} Copy`,
                    visible: true,
                    opacity: currentLayerData.opacity
                };
                
                // Copy the content
                const newCtx = newLayer.canvas.getContext('2d');
                newCtx.drawImage(currentLayerData.canvas, 0, 0);
                
                layers.push(newLayer);
                currentLayer = layers.length - 1;
                
                updateLayerList();
                addToHistory('Layer Duplicated');
            }
        }

        function deleteCurrentLayer() {
            if (layers.length > 1) {
                layers.splice(currentLayer, 1);
                currentLayer = Math.max(0, currentLayer - 1);
                updateLayerList();
                renderLayers();
                addToHistory('Layer Deleted');
            } else {
                alert('Cannot delete the last layer!');
            }
        }

        function mergeDown() {
            if (currentLayer > 0) {
                const upperLayer = layers[currentLayer];
                const lowerLayer = layers[currentLayer - 1];
                
                const lowerCtx = lowerLayer.canvas.getContext('2d');
                lowerCtx.globalAlpha = upperLayer.opacity;
                lowerCtx.drawImage(upperLayer.canvas, 0, 0);
                lowerCtx.globalAlpha = 1;
                
                layers.splice(currentLayer, 1);
                currentLayer--;
                
                updateLayerList();
                renderLayers();
                addToHistory('Layers Merged');
            } else {
                alert('Cannot merge down from the bottom layer!');
            }
        }

        function flattenImage() {
            if (layers.length > 1) {
                const flattenedCanvas = createLayerCanvas();
                const flattenedCtx = flattenedCanvas.getContext('2d');
                
                // Render all visible layers onto the flattened canvas
                layers.forEach(layer => {
                    if (layer.visible) {
                        flattenedCtx.globalAlpha = layer.opacity;
                        flattenedCtx.drawImage(layer.canvas, 0, 0);
                    }
                });
                
                layers = [{
                    canvas: flattenedCanvas,
                    name: 'Background',
                    visible: true,
                    opacity: 1
                }];
                
                currentLayer = 0;
                updateLayerList();
                renderLayers();
                addToHistory('Image Flattened');
            }
        }

        // About modal functions
        function showAbout() {
            const modal = document.getElementById('aboutModal');
            modal.classList.add('show');
        }

        function closeAboutModal(event) {
            const modal = document.getElementById('aboutModal');
            if (!event || event.target === modal) {
                modal.classList.remove('show');
            }
        }

        // Close modal with ESC key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeAboutModal();
            }
        });

        // Initialize the editor when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProPhoto Editor - Photoshop Clone by Kyros Koh</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c2c2c;
            color: #ffffff;
            overflow: hidden;
            /* Prevent text selection on mobile */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Prevent touch callouts and highlight */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Top Menu Bar */
        .menu-bar {
            background: #3c3c3c;
            padding: 8px 16px;
            border-bottom: 1px solid #555;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .menu-bar .menu-item {
            color: #fff;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .menu-bar .menu-item:hover {
            background: #555;
        }

        .menu-separator {
            width: 1px;
            height: 20px;
            background: #555;
        }

        /* Title Bar */
        .title-bar {
            background: #353535;
            padding: 6px 16px;
            border-bottom: 1px solid #555;
            display: flex;
            align-items: center;
            font-size: 13px;
            color: #ccc;
        }

        .title-bar .project-title {
            font-weight: 500;
            color: #fff;
        }

        .title-bar .unsaved-indicator {
            color: #ffaa00;
            margin-left: 4px;
        }

        /* Main Tool Bar */
        .toolbar {
            background: #3c3c3c;
            padding: 8px;
            border-bottom: 1px solid #555;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tool-group {
            display: flex;
            background: #4c4c4c;
            border-radius: 6px;
            padding: 2px;
            gap: 2px;
        }

        .tool-button {
            background: transparent;
            border: none;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            min-width: 36px;
            height: 36px;
        }

        .tool-button:hover:not(:disabled) {
            background: #555;
        }

        .tool-button.active {
            background: #0078d4;
            box-shadow: 0 0 0 1px #0078d4;
        }

        .tool-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .tool-separator {
            width: 1px;
            height: 32px;
            background: #666;
            margin: 0 4px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 8px;
        }

        .control-label {
            font-size: 12px;
            color: #ccc;
            min-width: 40px;
        }

        .control-input {
            background: #4c4c4c;
            border: 1px solid #666;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            width: 60px;
        }

        .color-picker {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Color Picker in Right Panel */
        .color-swatches {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        .color-swatch-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .color-swatch-label {
            font-size: 11px;
            color: #aaa;
            text-align: center;
        }

        .color-swatch-large {
            width: 100%;
            height: 60px;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s, box-shadow 0.1s;
            overflow: hidden;
        }

        .color-swatch-large:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .color-swatch-large:active {
            transform: scale(0.98);
        }

        .color-picker-hidden {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        .swap-colors-btn {
            width: 100%;
            height: 36px;
            background: #4c4c4c;
            border: 1px solid #666;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
            transition: background 0.2s;
        }

        .swap-colors-btn:hover {
            background: #555;
        }

        .swap-colors-btn:active {
            background: #666;
        }

        .reset-colors-btn {
            width: 100%;
            height: 32px;
            background: transparent;
            border: 1px solid #666;
            border-radius: 4px;
            color: #aaa;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 11px;
            transition: all 0.2s;
        }

        .reset-colors-btn:hover {
            background: #4c4c4c;
            color: #fff;
            border-color: #777;
        }

        .slider {
            width: 80px;
            height: 4px;
            border-radius: 2px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #0078d4;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Workspace Area */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* Left Tool Panel (Photoshop-style) */
        .tool-panel {
            position: fixed;
            left: 0;
            top: 100px;
            width: 60px;
            background: #3c3c3c;
            border-right: 1px solid #555;
            z-index: 100;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
            user-select: none;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .tool-panel.dragging {
            opacity: 0.8;
        }

        .tool-panel-header {
            height: 24px;
            background: #2c2c2c;
            border-bottom: 1px solid #555;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            font-size: 10px;
            position: relative;
        }

        .tool-panel-header:hover {
            background: #353535;
        }

        .tool-panel-header::after {
            content: '‚ãÆ‚ãÆ';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            letter-spacing: 2px;
        }

        .tool-panel-content {
            display: flex;
            flex-direction: column;
            padding: 4px;
            gap: 2px;
        }

        .tool-panel-button {
            width: 48px;
            height: 48px;
            background: transparent;
            border: none;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            position: relative;
        }

        .tool-panel-button:hover {
            background: #555;
        }

        .tool-panel-button.active {
            background: #0078d4;
            box-shadow: 0 0 0 1px #0078d4;
        }

        .tool-panel-button .icon {
            width: 24px;
            height: 24px;
        }

        .tool-panel-button .icon svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }

        /* Tool panel scrollbar */
        .tool-panel::-webkit-scrollbar {
            width: 4px;
        }

        .tool-panel::-webkit-scrollbar-track {
            background: #2c2c2c;
        }

        .tool-panel::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 2px;
        }

        .tool-panel::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        /* Right Panel */
        .side-panel {
            width: 280px;
            background: #3c3c3c;
            border-left: 1px solid #555;
            padding: 12px;
            overflow-y: auto;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #fff;
            border-bottom: 1px solid #555;
            padding-bottom: 4px;
        }

        /* Layers Panel */
        .layer-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .layer-item {
            background: #4c4c4c;
            border-radius: 4px;
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .layer-item:hover {
            background: #555;
        }

        .layer-item.active {
            background: #0078d4;
        }

        .layer-preview {
            width: 32px;
            height: 32px;
            background: #666;
            border-radius: 2px;
            border: 1px solid #777;
        }

        .layer-info {
            flex: 1;
        }

        .layer-name {
            font-size: 12px;
            font-weight: 500;
        }

        .layer-type {
            font-size: 10px;
            color: #ccc;
        }

        .layer-controls {
            display: flex;
            gap: 4px;
        }

        .layer-btn {
            background: transparent;
            border: none;
            color: #fff;
            padding: 4px;
            border-radius: 2px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .layer-btn:hover {
            background: #555;
        }

        /* History Panel */
        .history-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .history-item {
            background: #4c4c4c;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .history-item:hover {
            background: #555;
        }

        .history-item.active {
            background: #0078d4;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            position: relative;
            background: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
            margin-left: 60px; /* Space for tool panel */
        }

        .canvas-wrapper {
            position: relative;
            background: #888;
            box-shadow: 0 0 0 1px #999;
            transform-origin: center;
            cursor: crosshair;
            /* Improve touch handling */
            touch-action: none;
            -ms-touch-action: none;
        }

        .canvas-wrapper.pan-mode {
            cursor: grab;
        }

        .canvas-wrapper.pan-mode:active {
            cursor: grabbing;
        }

        canvas {
            /* Improve touch handling on canvas */
            touch-action: none;
            -ms-touch-action: none;
            /* Prevent image drag on mobile */
            -webkit-user-drag: none;
        }

        .checkered {
            background-image: 
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        /* Status Bar */
        .status-bar {
            background: #3c3c3c;
            padding: 4px 16px;
            border-top: 1px solid #555;
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 12px;
            color: #ccc;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Color Palette */
        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            margin-top: 8px;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 2px;
            cursor: pointer;
            border: 1px solid #666;
            transition: transform 0.1s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.active {
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px #0078d4;
        }

        /* File Input */
        .file-input {
            display: none;
        }

        /* Selection Rectangle */
        .selection-rect {
            position: absolute;
            border: 1px dashed #0078d4;
            background: rgba(0, 120, 212, 0.1);
            pointer-events: none;
        }

        /* Tool Settings Panel */
        .tool-settings {
            display: none;
            position: absolute;
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 12px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .tool-settings.visible {
            display: block;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .side-panel {
                width: 200px;
            }
        }

        @media (max-width: 768px) {
            .side-panel {
                width: 150px;
            }
            
            .panel-section {
                margin-bottom: 12px;
            }
            
            .panel-title {
                font-size: 12px;
            }
            
            .tool-panel {
                width: 50px;
            }
            
            .tool-panel-button {
                width: 42px;
                height: 42px;
            }
            
            .canvas-container {
                margin-left: 50px !important;
            }
        }

        /* Mobile Touch Improvements */
        @media (hover: none) and (pointer: coarse) {
            /* Increase touch target sizes for mobile */
            .tool-button {
                min-width: 44px;
                min-height: 44px;
                padding: 10px;
            }
            
            .layer-btn {
                min-width: 44px;
                min-height: 44px;
                padding: 8px;
            }
            
            .dropdown-item {
                padding: 12px 16px;
                min-height: 44px;
            }
            
            .menu-item {
                padding: 8px 12px;
                min-height: 44px;
            }
            
            /* Improve color picker touch target */
            .color-picker {
                width: 48px;
                height: 48px;
            }
            
            /* Better slider touch targets */
            .slider {
                height: 8px;
            }
            
            .slider::-webkit-slider-thumb {
                width: 20px;
                height: 20px;
            }
        }

        /* Icon Styles */
        .icon {
            width: 16px;
            height: 16px;
            display: inline-block;
        }

        .icon svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }

        /* Dropdown Menu Styles */
        .menu-item {
            position: relative;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            min-width: 180px;
            z-index: 1000;
            margin-top: 4px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            padding: 8px 16px;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 13px;
            border-bottom: 1px solid #4c4c4c;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background: #555;
        }

        .dropdown-item.disabled {
            color: #888;
            cursor: not-allowed;
        }

        .dropdown-item.disabled:hover {
            background: transparent;
        }

        .dropdown-divider {
            height: 1px;
            background: #555;
            margin: 4px 0;
        }

        /* About Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .modal-content.changelog-modal {
            max-width: 700px;
            max-height: 85vh;
        }

        #changelogContent {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        #changelogContent h2 {
            color: #fff;
            font-size: 20px;
            margin: 24px 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #555;
        }

        #changelogContent h3 {
            color: #4a9eff;
            font-size: 16px;
            margin: 20px 0 8px 0;
        }

        #changelogContent h4 {
            color: #fff;
            font-size: 14px;
            margin: 16px 0 6px 0;
            font-weight: 600;
        }

        #changelogContent ul {
            margin: 8px 0 8px 20px;
            padding-left: 0;
        }

        #changelogContent li {
            margin: 4px 0;
            color: #ccc;
        }

        #changelogContent code {
            background: #2c2c2c;
            padding: 2px 6px;
            border-radius: 3px;
            color: #ffaa00;
            font-size: 12px;
        }

        #changelogContent a {
            color: #0078d4;
            text-decoration: none;
        }

        #changelogContent a:hover {
            text-decoration: underline;
        }

        #changelogContent p {
            margin: 8px 0;
            color: #ccc;
        }

        #changelogContent strong {
            color: #fff;
        }

        #changelogContent .version-section {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid #444;
        }

        #changelogContent .version-section:last-child {
            border-bottom: none;
        }

        .modal-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
        }

        .modal-icon {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #0078d4, #00bcf2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            color: white;
        }

        .modal-title-block h2 {
            font-size: 24px;
            margin: 0;
            color: #fff;
        }

        .modal-title-block p {
            font-size: 14px;
            color: #aaa;
            margin: 4px 0 0 0;
        }

        .modal-body {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .modal-body h3 {
            color: #fff;
            font-size: 16px;
            margin: 16px 0 8px 0;
        }

        .modal-body p {
            margin: 8px 0;
            font-size: 14px;
        }

        .modal-body a {
            color: #0078d4;
            text-decoration: none;
        }

        .modal-body a:hover {
            text-decoration: underline;
        }

        .modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            color: #ccc;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: #555;
            color: #fff;
        }

        .modal-footer {
            display: flex;
            justify-content: center;
            gap: 12px;
        }

        .modal-button {
            background: #0078d4;
            border: none;
            color: #fff;
            padding: 10px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .modal-button:hover {
            background: #005a9e;
        }

        .modal-button.secondary {
            background: #4c4c4c;
        }

        .modal-button.secondary:hover {
            background: #555;
        }

        /* Restore Dialog */
        .restore-dialog {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 400px;
        }

        .restore-dialog-info {
            background: #4c4c4c;
            border-radius: 4px;
            padding: 12px;
            font-size: 12px;
            color: #ccc;
            line-height: 1.5;
        }

        .restore-dialog-info strong {
            color: #fff;
        }

        .restore-dialog-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .restore-dialog-buttons .modal-button {
            min-width: 120px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Menu Bar -->
        <div class="menu-bar">
            <div class="menu-item" onclick="toggleDropdown('fileMenu')">
                File
                <div class="dropdown-menu" id="fileMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); fileActions('new'); hideAllDropdowns();">New Document</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); fileActions('open'); hideAllDropdowns();">Open Image...</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); saveProject(); hideAllDropdowns();">Save Project...</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); loadProject(); hideAllDropdowns();">Load Project...</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); exportImage(); hideAllDropdowns();">Save As PNG...</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); saveAsJPEG(); hideAllDropdowns();">Save As JPEG...</div>
                </div>
            </div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="toggleDropdown('editMenu')">
                Edit
                <div class="dropdown-menu" id="editMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); undoAction(); hideAllDropdowns();">Undo (Ctrl+Z)</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); redoAction(); hideAllDropdowns();">Redo (Ctrl+Shift+Z)</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); clearCanvas(); hideAllDropdowns();">Clear Canvas</div>
                </div>
            </div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="toggleDropdown('viewMenu')">
                View
                <div class="dropdown-menu" id="viewMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); toggleGrid(); hideAllDropdowns();">Toggle Grid</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); fitToScreen(); hideAllDropdowns();">Fit to Screen</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); actualSize(); hideAllDropdowns();">Actual Size (100%)</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); zoomIn(); hideAllDropdowns();">Zoom In</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); zoomOut(); hideAllDropdowns();">Zoom Out</div>
                </div>
            </div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="toggleDropdown('filterMenu')">
                Filters
                <div class="dropdown-menu" id="filterMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); applyFilter('brightness'); hideAllDropdowns();">Brightness</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); applyFilter('contrast'); hideAllDropdowns();">Contrast</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); applyFilter('blur'); hideAllDropdowns();">Blur</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); applyFilter('sharpen'); hideAllDropdowns();">Sharpen</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); applyFilter('grayscale'); hideAllDropdowns();">Grayscale</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); invertColors(); hideAllDropdowns();">Invert Colors</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); applySepia(); hideAllDropdowns();">Sepia</div>
                </div>
            </div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="toggleDropdown('layerMenu')">
                Layer
                <div class="dropdown-menu" id="layerMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); addNewLayer(); hideAllDropdowns();">New Layer</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); duplicateCurrentLayer(); hideAllDropdowns();">Duplicate Layer</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); deleteCurrentLayer(); hideAllDropdowns();">Delete Layer</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); mergeDown(); hideAllDropdowns();">Merge Down</div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); flattenImage(); hideAllDropdowns();">Flatten Image</div>
                </div>
            </div>
            <div class="menu-separator"></div>
            <div class="menu-item" onclick="toggleDropdown('helpMenu')">
                Help
                <div class="dropdown-menu" id="helpMenu">
                    <div class="dropdown-item" onclick="event.stopPropagation(); showAbout(); hideAllDropdowns();">About ProPhoto Editor</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" onclick="event.stopPropagation(); showChangelog(); hideAllDropdowns();">Change Log</div>
                </div>
            </div>
        </div>

        <!-- Title Bar -->
        <div class="title-bar">
            <span>ProPhoto Editor</span>
            <span style="margin: 0 8px;">-</span>
            <span class="project-title" id="projectTitle">Untitled</span>
            <span class="unsaved-indicator" id="unsavedIndicator" style="display: none;">*</span>
        </div>

        <!-- Main Toolbar -->
        <div class="toolbar">
            <!-- Undo/Redo Buttons -->
            <div class="tool-group">
                <button class="tool-button" id="undoBtn" onclick="undoAction()" title="Undo (Ctrl+Z)">
                    <div class="icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 7v6h6"></path>
                            <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path>
                        </svg>
                    </div>
                </button>
                <button class="tool-button" id="redoBtn" onclick="redoAction()" title="Redo (Ctrl+Shift+Z)">
                    <div class="icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 7v6h-6"></path>
                            <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"></path>
                        </svg>
                    </div>
                </button>
            </div>

            <div class="tool-separator"></div>

            <!-- Control Groups -->
            <div class="control-group">
                <span class="control-label">Size:</span>
                <input type="range" class="slider" id="sizeSlider" min="1" max="100" value="10" onchange="updateSize()">
                <span id="sizeDisplay">10</span>px
            </div>

            <div class="control-group">
                <span class="control-label">Opacity:</span>
                <input type="range" class="slider" id="opacitySlider" min="1" max="100" value="100" onchange="updateOpacity()">
                <span id="opacityDisplay">100</span>%
            </div>

            <div class="control-group">
                <span class="control-label">Zoom:</span>
                <input type="range" class="slider" id="zoomSlider" min="10" max="500" value="100" onchange="updateZoom()">
                <span id="zoomDisplay">100</span>%
                <button class="tool-button" onclick="fitToScreen()">Fit</button>
                <button class="tool-button" onclick="actualSize()">100%</button>
            </div>
        </div>

        <!-- Left Tool Panel (Photoshop-style) -->
        <div class="tool-panel" id="toolPanel">
            <div class="tool-panel-header" id="toolPanelHeader"></div>
            <div class="tool-panel-content">
                <button class="tool-panel-button active" id="moveTool" onclick="selectTool('move')" title="Move Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2L8 6h3v4H5l4 4V10h4l-2 2h-2v4H8l-2 2h4l4-4h-3v-4h6l-4-4v-2h2l2-2H8l4-4z"/></svg>
                    </div>
                </button>
                <button class="tool-panel-button" id="marqueeTool" onclick="selectTool('marquee')" title="Rectangular Marquee">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"/></svg>
                    </div>
                </button>
                <button class="tool-panel-button" id="lassoTool" onclick="selectTool('lasso')" title="Lasso Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><path d="M8 2L6 8l4 2L8 12l-4 4 6 2 4-6 2-2L12 8z" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-panel-button" id="magicWandTool" onclick="selectTool('magicWand')" title="Magic Wand">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2L8 6h3l2 2-2 2-2 2h3l2 2-2 2-3 3-3-3-3 3-3-3 3-3-2-2 2-2-2-2 2-2 3 3z" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-panel-button" id="brushTool" onclick="selectTool('brush')" title="Brush Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><circle cx="8" cy="8" r="3" fill="currentColor"/><rect x="14" y="14" width="6" height="2" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-panel-button" id="pencilTool" onclick="selectTool('pencil')" title="Pencil Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><rect x="3" y="15" width="8" height="4" fill="currentColor"/><rect x="11" y="13" width="10" height="2" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-panel-button" id="eraserTool" onclick="selectTool('eraser')" title="Eraser Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><path d="M16.24 3.56L15.77 3.09L14.24 4.62L14.71 5.09L16.24 3.56M21.9 2.34L21.66 1.1L20.5 1.1L21.84 2.44L21.9 2.34" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-panel-button" id="sprayTool" onclick="selectTool('spray')" title="Spray Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><circle cx="8" cy="8" r="6" fill="currentColor" opacity="0.3"/><circle cx="8" cy="8" r="2" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-panel-button" id="textTool" onclick="selectTool('text')" title="Text Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><text x="12" y="16" text-anchor="middle" font-size="12" fill="currentColor">A</text></svg>
                    </div>
                </button>
                <button class="tool-panel-button" id="fillTool" onclick="selectTool('fill')" title="Fill Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2L4 14h16L12 2zM8 18l-4 6h16l-4-6H8z" fill="currentColor"/></svg>
                    </div>
                </button>
                <button class="tool-panel-button" id="cropTool" onclick="selectTool('crop')" title="Crop Tool">
                    <div class="icon">
                        <svg viewBox="0 0 24 24"><rect x="4" y="4" width="6" height="6" stroke="currentColor" stroke-width="2" fill="none"/><rect x="14" y="4" width="6" height="6" stroke="currentColor" stroke-width="2" fill="none"/><rect x="4" y="14" width="6" height="6" stroke="currentColor" stroke-width="2" fill="none"/><rect x="14" y="14" width="6" height="6" stroke="currentColor" stroke-width="2" fill="none"/></svg>
                    </div>
                </button>
            </div>
        </div>

        <!-- Workspace -->
        <div class="workspace">
            <!-- Canvas Container (Left) -->
            <div class="canvas-container" id="canvasContainer">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="mainCanvas" class="checkered"></canvas>
                    <canvas id="gridCanvas" class="grid-overlay"></canvas>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="side-panel">
                <!-- Layers Panel -->
                <div class="panel-section">
                    <div class="panel-title">Layers</div>
                    <div class="layer-list" id="layerList">
                        <div class="layer-item active">
                            <div class="layer-preview checkered"></div>
                            <div class="layer-info">
                                <div class="layer-name">Background</div>
                                <div class="layer-type">Background</div>
                            </div>
                            <div class="layer-controls">
                                <button class="layer-btn" onclick="toggleLayerVisibility(0)">üëÅ</button>
                                <button class="layer-btn" onclick="duplicateLayer(0)">üìã</button>
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 8px;">
                        <button class="tool-button" onclick="addNewLayer()" style="width: 100%;">+ Add Layer</button>
                    </div>
                </div>

                <!-- History Panel -->
                <div class="panel-section">
                    <div class="panel-title">History</div>
                    <div class="history-list" id="historyList">
                        <div class="history-item active">Document Created</div>
                    </div>
                </div>

                <!-- Color Picker -->
                <div class="panel-section">
                    <div class="panel-title">Colors</div>
                    
                    <!-- Primary and Secondary Color Swatches -->
                    <div class="color-swatches">
                        <div class="color-swatch-container">
                            <div class="color-swatch-label">Foreground</div>
                            <div class="color-swatch-large" id="primaryColorSwatch" onclick="document.getElementById('primaryColorInput').click()" style="background-color: #000000;">
                                <input type="color" class="color-picker-hidden" id="primaryColorInput" value="#000000" onchange="updateColorFromPicker('primary')">
                            </div>
                        </div>
                        <div class="color-swatch-container">
                            <div class="color-swatch-label">Background</div>
                            <div class="color-swatch-large" id="secondaryColorSwatch" onclick="document.getElementById('secondaryColorInput').click()" style="background-color: #ffffff;">
                                <input type="color" class="color-picker-hidden" id="secondaryColorInput" value="#ffffff" onchange="updateColorFromPicker('secondary')">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Swap Colors Button -->
                    <button class="swap-colors-btn" onclick="swapColors()" title="Swap Colors">
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                            <path d="M16 17.01V10h-2v7.01h-3L15 21l4-3.99h-3zM9 3L5 6.99h3V14h2V6.99h3L9 3z"/>
                        </svg>
                    </button>
                    
                    <!-- Reset to Default Colors -->
                    <button class="reset-colors-btn" onclick="resetColors()" title="Reset to Default (Black/White)">
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                        </svg>
                        Reset
                    </button>
                    
                    <!-- Color Palette -->
                    <div style="margin-top: 16px;">
                        <div class="panel-title" style="font-size: 12px; margin-bottom: 8px;">Color Palette</div>
                    <div class="color-palette" id="colorPalette">
                        <!-- Colors will be populated by JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- Filters -->
                <div class="panel-section">
                    <div class="panel-title">Filters</div>
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <button class="tool-button" onclick="applyFilter('brightness')">Brightness</button>
                        <button class="tool-button" onclick="applyFilter('contrast')">Contrast</button>
                        <button class="tool-button" onclick="applyFilter('blur')">Blur</button>
                        <button class="tool-button" onclick="applyFilter('sharpen')">Sharpen</button>
                        <button class="tool-button" onclick="applyFilter('grayscale')">Grayscale</button>
                        <button class="tool-button" onclick="invertColors()">Invert Colors</button>
                        <button class="tool-button" onclick="applySepia()">Sepia</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">Tool: <span id="currentTool">Move</span></div>
            <div class="status-item">Position: <span id="mousePosition">0, 0</span></div>
            <div class="status-item">Size: <span id="canvasSize">800 √ó 600</span></div>
            <div class="status-item">Zoom: <span id="statusZoom">100%</span></div>
        </div>
    </div>

    <!-- Hidden File Inputs -->
    <input type="file" class="file-input" id="fileInput" accept="image/*" onchange="loadImage(event)">
    <input type="file" class="file-input" id="projectFileInput" accept=".prophoto" onchange="handleProjectLoad(event)" style="display: none;">

    <!-- About Modal -->
    <div class="modal-overlay" id="aboutModal" onclick="closeAboutModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="closeAboutModal()">&times;</button>
            <div class="modal-header">
                <div class="modal-icon">P</div>
                <div class="modal-title-block">
                    <h2>ProPhoto Editor</h2>
                    <p>Version 1.0.0</p>
                </div>
            </div>
            <div class="modal-body">
                <p><strong>A browser-based Photoshop clone</strong> built with HTML5 Canvas, CSS3, and Vanilla JavaScript.</p>
                
                <h3>About This Project</h3>
                <p>ProPhoto Editor brings professional-grade image editing capabilities to the web. Inspired by Adobe Photoshop, this application provides a comprehensive set of drawing tools, filters, and layer management features ‚Äî all running entirely in your browser with zero dependencies.</p>
                
                <p>New in this version: Save and load projects in custom .prophoto format, automatic session state saving, and project title bar with unsaved changes indicator. Your work is automatically saved to localStorage, so you can resume editing even after closing the browser!</p>
                
                <h3>Creator</h3>
                <p><strong>Kyros Koh</strong><br>
                Full-stack developer passionate about creating powerful web applications.</p>
                
                <h3>Features</h3>
                <p>‚úì 10 Professional drawing & selection tools<br>
                ‚úì Multi-layer support with opacity control<br>
                ‚úì 7 Image filters and effects<br>
                ‚úì Undo/Redo system (20+ steps)<br>
                ‚úì Project save/load (.prophoto format)<br>
                ‚úì Auto-save session state to localStorage<br>
                ‚úì Unsaved changes indicator<br>
                ‚úì Export to PNG/JPEG<br>
                ‚úì Mobile touch support<br>
                ‚úì Completely free and open-source</p>
                
                <h3>Links</h3>
                <p>
                    <a href="https://kyroskoh.github.io/photoshop-clone/" target="_blank">Live Demo</a> ‚Ä¢
                    <a href="https://github.com/kyroskoh/photoshop-clone" target="_blank">GitHub Repository</a>
                </p>
                
                <p style="margin-top: 20px; font-size: 12px; color: #888;">
                    ¬© 2025 Kyros Koh. Licensed under MIT License.
                </p>
            </div>
            <div class="modal-footer">
                <button class="modal-button" onclick="closeAboutModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Changelog Modal -->
    <div class="modal-overlay" id="changelogModal" style="display: none;" onclick="closeChangelogModal(event)">
        <div class="modal-content changelog-modal" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="closeChangelogModal()">&times;</button>
            <div class="modal-header">
                <div class="modal-icon">üìã</div>
                <div class="modal-title-block">
                    <h2>Change Log</h2>
                    <p>Version History</p>
                </div>
            </div>
            <div class="modal-body">
                <div id="changelogContent" style="max-height: 60vh; overflow-y: auto; padding-right: 8px;">
                    <div style="text-align: center; padding: 20px; color: #888;">
                        <p>Loading changelog...</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-button" onclick="closeChangelogModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Restore Dialog -->
    <div class="modal-overlay" id="restoreDialog" style="display: none;" onclick="event.stopPropagation()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-icon">üíæ</div>
                <div class="modal-title-block">
                    <h2>Restore Previous Work?</h2>
                    <p>We found saved work from a previous session</p>
                </div>
            </div>
            <div class="modal-body">
                <div class="restore-dialog">
                    <p>Would you like to restore your previous work or start a new session?</p>
                    
                    <div class="restore-dialog-info" id="restoreDialogInfo">
                        <strong>Last saved:</strong> <span id="restoreDialogTime"></span><br>
                        <strong>Canvas size:</strong> <span id="restoreDialogSize"></span><br>
                        <strong>Layers:</strong> <span id="restoreDialogLayers"></span>
                    </div>
                    
                    <div class="restore-dialog-buttons">
                        <button class="modal-button secondary" onclick="startNewSession()">Start New Session</button>
                        <button class="modal-button" onclick="restorePreviousWork()">Restore Previous Work</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global Variables
        let canvas, ctx, gridCanvas, gridCtx;
        let mainCanvas = document.getElementById('mainCanvas');
        let canvasWrapper = document.getElementById('canvasWrapper');
        let isDrawing = false;
        let currentTool = 'move';
        let primaryColor = '#000000';
        let secondaryColor = '#ffffff';
        let brushSize = 10;
        let opacity = 1;
        let zoom = 1;
        let panX = 0, panY = 0;
        let startX, startY, endX, endY;
        let layers = [];
        let currentLayer = 0;
        let history = [];
        let historyStates = [];
        let historyIndex = -1;
        let showGrid = false;
        let magicWandTolerance = 32;
        let selectedArea = null;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let saveTimeout = null;
        let projectName = 'Untitled';
        let hasUnsavedChanges = false;
        let currentProjectPath = null; // Store the file path if saved

        // Initialize the editor
        function init() {
            canvas = document.getElementById('mainCanvas');
            gridCanvas = document.getElementById('gridCanvas');
            ctx = canvas.getContext('2d');
            gridCtx = gridCanvas.getContext('2d');
            
            // Set initial canvas size
            canvas.width = 800;
            canvas.height = 600;
            gridCanvas.width = canvas.width;
            gridCanvas.height = canvas.height;
            
            // Initialize layers with white background layer
            const backgroundLayer = createLayerCanvas();
            const bgCtx = backgroundLayer.getContext('2d');
            bgCtx.fillStyle = '#ffffff';
            bgCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            layers.push({
                canvas: backgroundLayer,
                name: 'Background',
                visible: true,
                opacity: 1
            });
            
            // Initialize color palette
            initColorPalette();
            
            // Initialize color swatches
            updatePrimaryColorSwatch(primaryColor);
            updateSecondaryColorSwatch(secondaryColor);
            
            // Initialize project title
            updateProjectTitle();
            
            // Add event listeners
            addEventListeners();
            
            // Initialize tool panel dragging
            initToolPanelDrag();
            
            // Check for saved state and prompt user
            checkForSavedState();
            
            // Save state periodically and on page unload
            setupAutoSave();
        }

        // Check for saved state and prompt user
        function checkForSavedState() {
            const savedState = localStorage.getItem('proPhotoEditorState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    // Render initial background while dialog is shown
                    renderLayers();
                    updateLayerList();
                    // Show restore dialog
                    showRestoreDialog(state);
                } catch (e) {
                    console.error('Error parsing saved state:', e);
                    // If error parsing, start new session
                    initializeNewDocument();
                }
            } else {
                // No saved state, start new document
                initializeNewDocument();
            }
        }

        // Show restore dialog with saved state information
        function showRestoreDialog(state) {
            const dialog = document.getElementById('restoreDialog');
            const timeSpan = document.getElementById('restoreDialogTime');
            const sizeSpan = document.getElementById('restoreDialogSize');
            const layersSpan = document.getElementById('restoreDialogLayers');
            
            // Format timestamp
            if (state.timestamp) {
                const date = new Date(state.timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);
                
                let timeText;
                if (diffMins < 1) {
                    timeText = 'Just now';
                } else if (diffMins < 60) {
                    timeText = `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
                } else if (diffHours < 24) {
                    timeText = `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
                } else if (diffDays < 7) {
                    timeText = `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
                } else {
                    timeText = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                }
                timeSpan.textContent = timeText;
            } else {
                timeSpan.textContent = 'Unknown';
            }
            
            // Show canvas size
            if (state.canvas) {
                sizeSpan.textContent = `${state.canvas.width} √ó ${state.canvas.height}`;
            } else {
                sizeSpan.textContent = 'Unknown';
            }
            
            // Show layer count
            if (state.layers && state.layers.length > 0) {
                layersSpan.textContent = `${state.layers.length} layer${state.layers.length > 1 ? 's' : ''}`;
            } else {
                layersSpan.textContent = 'No layers';
            }
            
            // Show dialog (remove inline style to allow CSS class to work)
            dialog.style.display = '';
            dialog.classList.add('show');
        }

        // Restore previous work
        function restorePreviousWork() {
            const dialog = document.getElementById('restoreDialog');
            dialog.classList.remove('show');
            dialog.style.display = 'none';
            
            if (loadEditorState()) {
                showNotification('Work restored successfully', 2000);
            } else {
                showNotification('Error restoring work. Starting new session.', 3000);
                initializeNewDocument();
            }
        }

        // Start new session (clear saved state)
        function startNewSession() {
            const dialog = document.getElementById('restoreDialog');
            dialog.classList.remove('show');
            dialog.style.display = 'none';
            
            // Clear saved state
            clearSavedState();
            
            // Initialize new document
            initializeNewDocument();
            
            showNotification('Started new session', 2000);
        }

        // Initialize new document
        function initializeNewDocument() {
            // Set canvas size
            canvas.width = 800;
            canvas.height = 600;
            gridCanvas.width = canvas.width;
            gridCanvas.height = canvas.height;
            
            // Create white background layer
            const backgroundLayer = createLayerCanvas();
            const bgCtx = backgroundLayer.getContext('2d');
            bgCtx.fillStyle = '#ffffff';
            bgCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Initialize layers with background
            layers = [{
                canvas: backgroundLayer,
                name: 'Background',
                visible: true,
                opacity: 1
            }];
            
            currentLayer = 0;
            
            // Render initial canvas
            renderLayers();
            updateLayerList();
            
            // Save initial state and add to history
            history = [];
            historyStates = [];
            historyIndex = -1;
            history.push('Document Created');
            historyStates.push(saveCanvasState());
            historyIndex = 0;
            updateHistoryDisplay();
            
            // Reset project name
            projectName = 'Untitled';
            currentProjectPath = null;
            markSaved();
            updateProjectTitle();
            
            // Save initial state to localStorage
            setTimeout(() => {
                saveEditorState(true);
            }, 100);
        }

        // Update project title in title bar
        function updateProjectTitle() {
            const titleElement = document.getElementById('projectTitle');
            const unsavedIndicator = document.getElementById('unsavedIndicator');
            
            if (titleElement) {
                titleElement.textContent = projectName;
            }
            
            if (unsavedIndicator) {
                unsavedIndicator.style.display = hasUnsavedChanges ? 'inline' : 'none';
            }
        }

        // Mark project as having unsaved changes
        function markUnsaved() {
            hasUnsavedChanges = true;
            updateProjectTitle();
        }

        // Mark project as saved
        function markSaved() {
            hasUnsavedChanges = false;
            updateProjectTitle();
        }

        // XOR encoding/decoding for .prophoto file format
        function xorEncode(data, key) {
            const dataArray = new Uint8Array(data);
            const keyArray = new Uint8Array(new TextEncoder().encode(key));
            const result = new Uint8Array(dataArray.length);
            
            for (let i = 0; i < dataArray.length; i++) {
                result[i] = dataArray[i] ^ keyArray[i % keyArray.length];
            }
            
            return result;
        }

        function xorDecode(encodedData, key) {
            // XOR is symmetric, so encoding and decoding are the same
            return xorEncode(encodedData, key);
        }

        // Save editor state to localStorage
        function saveEditorState(immediate = false) {
            // Debounce saves to avoid too frequent writes (except for immediate saves)
            if (!immediate) {
                if (saveTimeout) {
                    clearTimeout(saveTimeout);
                }
                saveTimeout = setTimeout(() => {
                    performSave();
                }, 1000); // Wait 1 second after last action
                return;
            }
            
            // Immediate save (for beforeunload, etc.)
            performSave();
        }

        // Perform the actual save operation
        function performSave() {
            try {
                // Only save if we have layers
                if (!layers || layers.length === 0) {
                    console.warn('No layers to save');
                    return false;
                }
                
                const state = {
                    version: '1.0',
                    timestamp: Date.now(),
                    projectName: projectName,
                    canvas: {
                        width: canvas.width,
                        height: canvas.height
                    },
                    layers: layers.map(layer => ({
                        imageData: layer.canvas.toDataURL('image/png'),
                        name: layer.name,
                        visible: layer.visible,
                        opacity: layer.opacity
                    })),
                    currentLayer: currentLayer,
                    colors: {
                        primary: primaryColor,
                        secondary: secondaryColor
                    },
                    tool: currentTool,
                    settings: {
                        brushSize: brushSize,
                        opacity: opacity,
                        zoom: zoom
                    },
                    history: history || [],
                    historyIndex: historyIndex !== undefined ? historyIndex : -1,
                    historyStates: (historyStates || []).map(state => ({
                        layers: (state.layers || []).map(layer => ({
                            imageData: layer.imageData,
                            name: layer.name,
                            visible: layer.visible,
                            opacity: layer.opacity
                        })),
                        currentLayer: state.currentLayer
                    }))
                };
                
                const stateString = JSON.stringify(state);
                localStorage.setItem('proPhotoEditorState', stateString);
                console.log('State saved successfully', { layers: state.layers.length, timestamp: new Date(state.timestamp).toLocaleString() });
                return true;
            } catch (e) {
                console.error('Error saving editor state:', e);
                // Handle quota exceeded error
                if (e.name === 'QuotaExceededError') {
                    alert('Storage quota exceeded. Unable to save state. Please clear some data or export your work.');
                }
                return false;
            }
        }

        // Load editor state from localStorage
        function loadEditorState() {
            try {
                const savedState = localStorage.getItem('proPhotoEditorState');
                if (!savedState) {
                    console.log('No saved state found in localStorage');
                    return false;
                }
                
                const state = JSON.parse(savedState);
                console.log('Loading saved state', { 
                    layers: state.layers?.length || 0, 
                    timestamp: state.timestamp ? new Date(state.timestamp).toLocaleString() : 'unknown' 
                });
                
                // Restore canvas size
                canvas.width = state.canvas.width;
                canvas.height = state.canvas.height;
                gridCanvas.width = canvas.width;
                gridCanvas.height = canvas.height;
                
                // Restore layers
                layers = [];
                let loadedLayers = 0;
                const totalLayers = state.layers.length;
                
                if (totalLayers === 0) {
                    return false;
                }
                
                state.layers.forEach((layerData, i) => {
                    const img = new Image();
                    img.onload = function() {
                        const newLayer = {
                            canvas: createLayerCanvas(),
                            name: layerData.name,
                            visible: layerData.visible !== undefined ? layerData.visible : true,
                            opacity: layerData.opacity !== undefined ? layerData.opacity : 1
                        };
                        
                        const layerCtx = newLayer.canvas.getContext('2d');
                        layerCtx.drawImage(img, 0, 0);
                        layers[i] = newLayer;
                        
                        loadedLayers++;
                        if (loadedLayers === totalLayers) {
                            // All layers loaded, restore other state
                            currentLayer = state.currentLayer || 0;
                            
                            // Restore project name
                            if (state.projectName) {
                                projectName = state.projectName;
                                updateProjectTitle();
                            }
                            
                            // Restore colors
                            if (state.colors) {
                                primaryColor = state.colors.primary || '#000000';
                                secondaryColor = state.colors.secondary || '#ffffff';
                                updatePrimaryColorSwatch(primaryColor);
                                updateSecondaryColorSwatch(secondaryColor);
                            }
                            
                            // Restore tool
                            if (state.tool) {
                                selectTool(state.tool);
                            }
                            
                            // Restore settings
                            if (state.settings) {
                                brushSize = state.settings.brushSize || 10;
                                opacity = state.settings.opacity !== undefined ? state.settings.opacity : 1;
                                zoom = state.settings.zoom || 1;
                                
                                // Update UI
                                document.getElementById('sizeSlider').value = brushSize;
                                document.getElementById('sizeDisplay').textContent = brushSize;
                                document.getElementById('opacitySlider').value = Math.round(opacity * 100);
                                document.getElementById('opacityDisplay').textContent = Math.round(opacity * 100);
                                document.getElementById('zoomSlider').value = zoom * 100;
                                document.getElementById('zoomDisplay').textContent = Math.round(zoom * 100);
                                document.getElementById('statusZoom').textContent = Math.round(zoom * 100) + '%';
                                updateZoom();
                            }
                            
                            // Restore history
                            if (state.history && state.history.length > 0) {
                                history = state.history;
                                historyIndex = state.historyIndex !== undefined ? state.historyIndex : history.length - 1;
                                
                                // Restore history states
                                if (state.historyStates && state.historyStates.length > 0) {
                                    historyStates = state.historyStates;
                                }
                            } else {
                                // Create initial history
                                history = ['Document Restored'];
                                historyStates = [saveCanvasState()];
                                historyIndex = 0;
                            }
                            
                            // Update UI
                            updateLayerList();
                            renderLayers();
                            updateHistoryDisplay();
                            
                            console.log('State restored successfully');
                        }
                    };
                    img.onerror = function() {
                        console.error('Error loading layer image', layerData);
                        loadedLayers++;
                        if (loadedLayers === totalLayers) {
                            // Even if some layers failed, try to continue
                            updateLayerList();
                            renderLayers();
                            console.log('State restored with some errors');
                        }
                    };
                    img.src = layerData.imageData;
                });
                
                return true;
            } catch (e) {
                console.error('Error loading editor state:', e);
                return false;
            }
        }

        // Clear saved state from localStorage
        function clearSavedState() {
            try {
                localStorage.removeItem('proPhotoEditorState');
                return true;
            } catch (e) {
                console.error('Error clearing saved state:', e);
                return false;
            }
        }

        // Setup auto-save functionality
        function setupAutoSave() {
            // Save state periodically (every 30 seconds)
            setInterval(() => {
                saveEditorState(true); // Immediate save for periodic saves
            }, 30000);
            
            // Save state before page unload (immediate)
            window.addEventListener('beforeunload', () => {
                saveEditorState(true);
            });
            
            // Save state when visibility changes (tab switch) - immediate
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    saveEditorState(true);
                }
            });
        }

        // Show notification
        function showNotification(message, duration = 2000) {
            // Remove existing notification if any
            const existing = document.getElementById('saveNotification');
            if (existing) {
                existing.remove();
            }
            
            const notification = document.createElement('div');
            notification.id = 'saveNotification';
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: #0078d4;
                color: white;
                padding: 12px 20px;
                border-radius: 4px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                z-index: 10000;
                font-size: 14px;
                animation: slideIn 0.3s ease-out;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => notification.remove(), 300);
            }, duration);
        }

        // Add CSS for notification animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            @keyframes slideOut {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);

        // Tool panel drag functionality
        function initToolPanelDrag() {
            const toolPanel = document.getElementById('toolPanel');
            const toolPanelHeader = document.getElementById('toolPanelHeader');
            const canvasContainer = document.getElementById('canvasContainer');
            let isDragging = false;
            let currentX = 0;
            let currentY = 0;
            let initialX = 0;
            let initialY = 0;
            let xOffset = 0;
            let yOffset = 0;

            // Load saved position from localStorage
            const savedPosition = localStorage.getItem('toolPanelPosition');
            if (savedPosition) {
                const pos = JSON.parse(savedPosition);
                xOffset = pos.x;
                yOffset = pos.y;
                toolPanel.style.left = pos.x + 'px';
                toolPanel.style.top = pos.y + 'px';
                updateCanvasMargin(pos.x);
            }

            toolPanelHeader.addEventListener('mousedown', dragStart);
            toolPanelHeader.addEventListener('touchstart', dragStart, { passive: false });

            function dragStart(e) {
                if (e.type === 'touchstart') {
                    initialX = e.touches[0].clientX - xOffset;
                    initialY = e.touches[0].clientY - yOffset;
                } else {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                }

                if (e.target === toolPanelHeader || toolPanelHeader.contains(e.target)) {
                    isDragging = true;
                    toolPanel.classList.add('dragging');
                    e.preventDefault();
                }
            }

            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    
                    if (e.type === 'touchmove') {
                        currentX = e.touches[0].clientX - initialX;
                        currentY = e.touches[0].clientY - initialY;
                    } else {
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                    }

                    xOffset = currentX;
                    yOffset = currentY;

                    // Constrain to viewport
                    const maxX = window.innerWidth - toolPanel.offsetWidth;
                    const maxY = window.innerHeight - toolPanel.offsetHeight;
                    xOffset = Math.max(0, Math.min(xOffset, maxX));
                    yOffset = Math.max(0, Math.min(yOffset, maxY));

                    toolPanel.style.left = xOffset + 'px';
                    toolPanel.style.top = yOffset + 'px';
                    
                    updateCanvasMargin(xOffset);
                }
            }

            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('touchend', dragEnd);

            function dragEnd() {
                if (isDragging) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    toolPanel.classList.remove('dragging');
                    
                    // Save position to localStorage
                    localStorage.setItem('toolPanelPosition', JSON.stringify({
                        x: xOffset,
                        y: yOffset
                    }));
                }
            }

            function updateCanvasMargin(panelX) {
                // Update canvas container margin based on tool panel position
                const panelWidth = toolPanel.offsetWidth;
                if (panelX < 100) {
                    // Panel is on the left
                    canvasContainer.style.marginLeft = panelWidth + 'px';
                } else {
                    // Panel is moved away
                    canvasContainer.style.marginLeft = '0';
                }
            }
            
            // Update margin on window resize
            window.addEventListener('resize', () => {
                const rect = toolPanel.getBoundingClientRect();
                updateCanvasMargin(rect.left);
            });
        }

        // Create a new layer canvas
        function createLayerCanvas() {
            const layerCanvas = document.createElement('canvas');
            layerCanvas.width = canvas.width;
            layerCanvas.height = canvas.height;
            const layerCtx = layerCanvas.getContext('2d');
            layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
            return layerCanvas;
        }

        // Initialize color palette
        function initColorPalette() {
            const colors = [
                '#ffffff', '#000000', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff',
                '#800000', '#808000', '#008000', '#800080', '#008080', '#808080', '#ffa500', '#ffc0cb',
                '#a52a2a', '#f5deb3', '#90ee90', '#ffb6c1', '#20b2aa', '#87ceeb', '#dda0dd', '#98fb98',
                '#f0e68c', '#cd853f', '#40e0d0', '#ee82ee', '#ff6347', '#ffe4b5', '#d8bfd8', '#1e90ff'
            ];
            
            const palette = document.getElementById('colorPalette');
            colors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.onclick = () => setColor(color);
                palette.appendChild(swatch);
            });
        }

        // Add event listeners
        function addEventListeners() {
            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            
            // Touch events for mobile support
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);
            
            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyDown);
            
            // Prevent context menu
            canvas.addEventListener('contextmenu', e => e.preventDefault());
        }

        // Get coordinates from mouse or touch event
        function getEventCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            
            if (e.touches && e.touches.length > 0) {
                // Touch event
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                // Mouse event
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            
            return { x, y };
        }

        // Handle pointer down (mouse or touch start)
        function handlePointerDown(e, x, y) {
            startX = x;
            startY = y;
            isDrawing = true;
            
            if (currentTool === 'brush' || currentTool === 'pencil' || currentTool === 'eraser' || currentTool === 'spray') {
                useBrush(x, y, false);
            } else if (currentTool === 'marquee') {
                startMarquee(x, y);
            } else if (currentTool === 'lasso') {
                startLasso(x, y);
            } else if (currentTool === 'magicWand') {
                selectMagicWand(x, y);
            } else if (currentTool === 'text') {
                showTextDialog(x, y);
            } else if (currentTool === 'fill') {
                floodFill(x, y, primaryColor);
            } else if (currentTool === 'crop') {
                startCrop(x, y);
            } else if (currentTool === 'move') {
                startPan(e);
            }
        }

        // Handle pointer move (mouse or touch move)
        function handlePointerMove(e, x, y) {
            // Update position display
            document.getElementById('mousePosition').textContent = `${Math.round(x)}, ${Math.round(y)}`;
            
            if (!isDrawing) return;
            
            endX = x;
            endY = y;
            
            if (currentTool === 'brush' || currentTool === 'pencil' || currentTool === 'eraser' || currentTool === 'spray') {
                useBrush(x, y, true);
            } else if (currentTool === 'marquee') {
                updateMarquee(x, y);
            } else if (currentTool === 'lasso') {
                updateLasso(x, y);
            } else if (currentTool === 'crop') {
                updateCrop(x, y);
            } else if (currentTool === 'move') {
                panCanvas(e);
            }
        }

        // Handle pointer up (mouse or touch end)
        function handlePointerUp() {
            if (isDrawing) {
                isDrawing = false;
                
                if (currentTool === 'marquee') {
                    endMarquee();
                } else if (currentTool === 'lasso') {
                    endLasso();
                } else if (currentTool === 'crop') {
                    endCrop();
                }
                
                // Add to history
                addToHistory(`Used ${currentTool} tool`);
            }
        }

        // Handle mouse down events
        function handleMouseDown(e) {
            const { x, y } = getEventCoordinates(e);
            handlePointerDown(e, x, y);
        }

        // Handle mouse move events
        function handleMouseMove(e) {
            const { x, y } = getEventCoordinates(e);
            handlePointerMove(e, x, y);
        }

        // Handle mouse up events
        function handleMouseUp(e) {
            handlePointerUp();
        }

        // Handle touch start events
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                e.preventDefault(); // Prevent scrolling and zooming
                const { x, y } = getEventCoordinates(e);
                handlePointerDown(e, x, y);
            }
        }

        // Handle touch move events
        function handleTouchMove(e) {
            if (e.touches.length === 1) {
                e.preventDefault(); // Prevent scrolling
                if (isDrawing) {
                    const { x, y } = getEventCoordinates(e);
                    handlePointerMove(e, x, y);
                }
            }
        }

        // Handle touch end events
        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                handlePointerUp();
                // Reset touch tracking for pan
                lastTouchX = 0;
                lastTouchY = 0;
            }
        }

        // Select tool
        function selectTool(tool) {
            currentTool = tool;
            
            // Update tool buttons (both toolbar and tool panel)
            document.querySelectorAll('.tool-button, .tool-panel-button').forEach(btn => btn.classList.remove('active'));
            const toolButton = document.getElementById(tool + 'Tool');
            if (toolButton) {
                toolButton.classList.add('active');
            }
            
            // Update cursor
            if (tool === 'move') {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'crosshair';
            }
            
            // Update status
            document.getElementById('currentTool').textContent = tool.charAt(0).toUpperCase() + tool.slice(1);
        }

        // Use brush/pencil/eraser/spray
        function useBrush(x, y, isDrawing) {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            
            layerCtx.globalAlpha = opacity;
            
            if (currentTool === 'eraser') {
                layerCtx.globalCompositeOperation = 'destination-out';
                layerCtx.strokeStyle = 'rgba(0,0,0,1)';
            } else {
                layerCtx.globalCompositeOperation = 'source-over';
                layerCtx.strokeStyle = primaryColor;
            }
            
            layerCtx.lineCap = 'round';
            layerCtx.lineJoin = 'round';
            layerCtx.lineWidth = brushSize;
            
            if (!isDrawing) {
                layerCtx.beginPath();
                layerCtx.moveTo(x, y);
                layerCtx.lineTo(x + 0.1, y + 0.1);
                layerCtx.stroke();
            } else {
                if (!layerCtx._isDrawing) {
                    layerCtx.beginPath();
                    layerCtx.moveTo(layerCtx._lastX || x, layerCtx._lastY || y);
                }
                layerCtx.lineTo(x, y);
                layerCtx.stroke();
            }
            
            layerCtx._isDrawing = isDrawing;
            layerCtx._lastX = x;
            layerCtx._lastY = y;
            
            renderLayers();
        }

        // Selection tools
        function startMarquee(x, y) {
            selectedArea = {x1: x, y1: y, x2: x, y2: y};
            updateSelectionDisplay();
        }

        function updateMarquee(x, y) {
            selectedArea.x2 = x;
            selectedArea.y2 = y;
            updateSelectionDisplay();
        }

        function endMarquee() {
            // Keep selection area for later use
            updateSelectionDisplay();
        }

        // Magic Wand selection
        function selectMagicWand(x, y) {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            const imageData = layerCtx.getImageData(x, y, 1, 1);
            const targetColor = imageData.data;
            
            const data = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
            const visited = new Set();
            const stack = [[x, y]];
            
            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                const key = `${cx},${cy}`;
                
                if (visited.has(key) || cx < 0 || cy < 0 || cx >= layer.canvas.width || cy >= layer.canvas.height) {
                    continue;
                }
                
                const pixel = data.data[(cy * layer.canvas.width + cx) * 4];
                const pr = data.data[(cy * layer.canvas.width + cx) * 4 + 1];
                const pg = data.data[(cy * layer.canvas.width + cx) * 4 + 2];
                const pb = data.data[(cy * layer.canvas.width + cx) * 4 + 3];
                
                const r = Math.abs(pixel - targetColor[0]);
                const g = Math.abs(pr - targetColor[1]);
                const b = Math.abs(pg - targetColor[2]);
                const a = Math.abs(pb - targetColor[3]);
                
                if (r + g + b + a > magicWandTolerance) continue;
                
                visited.add(key);
                stack.push([cx - 1, cy], [cx + 1, cy], [cx, cy - 1], [cx, cy + 1]);
            }
            
            // Create selection mask
            selectedArea = Array.from(visited).map(key => {
                const [x, y] = key.split(',').map(Number);
                return {x, y};
            });
            
            addToHistory('Magic Wand Selection');
        }

        // Flood fill
        function floodFill(startX, startY, fillColor) {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            const data = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
            
            const targetColor = getPixelColor(data, startX, startY);
            const hex = hexToRgb(fillColor);
            
            const visited = new Set();
            const stack = [[startX, startY]];
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key) || x < 0 || y < 0 || x >= layer.canvas.width || y >= layer.canvas.height) {
                    continue;
                }
                
                const currentColor = getPixelColor(data, x, y);
                
                if (colorsMatch(currentColor, targetColor)) {
                    setPixelColor(data, x, y, hex);
                    visited.add(key);
                    stack.push([x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]);
                }
            }
            
            layerCtx.putImageData(data, 0, 0);
            renderLayers();
        }

        // Text tool
        function showTextDialog(x, y) {
            const text = prompt('Enter text:');
            if (text) {
                const layer = layers[currentLayer];
                const layerCtx = layer.canvas.getContext('2d');
                
                layerCtx.globalAlpha = opacity;
                layerCtx.fillStyle = primaryColor;
                layerCtx.font = `${brushSize * 2}px Arial`;
                layerCtx.fillText(text, x, y);
                
                renderLayers();
                addToHistory('Text Added');
            }
        }

        // Render all layers
        function renderLayers() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            layers.forEach((layer, index) => {
                if (layer.visible) {
                    ctx.save();
                    ctx.globalAlpha = layer.opacity;
                    ctx.drawImage(layer.canvas, 0, 0);
                    ctx.restore();
                }
            });
            
            updateCanvasSize();
        }

        // Update canvas size
        function updateCanvasSize() {
            document.getElementById('canvasSize').textContent = `${canvas.width} √ó ${canvas.height}`;
            
            // Update grid canvas
            gridCanvas.width = canvas.width;
            gridCanvas.height = canvas.height;
        }

        // Save canvas state
        function saveCanvasState() {
            const state = {
                layers: layers.map(layer => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = layer.canvas.width;
                    tempCanvas.height = layer.canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(layer.canvas, 0, 0);
                    return {
                        imageData: tempCanvas.toDataURL(),
                        name: layer.name,
                        visible: layer.visible,
                        opacity: layer.opacity
                    };
                }),
                currentLayer: currentLayer
            };
            return state;
        }

        // Add to history
        function addToHistory(action) {
            // Remove future history if we're not at the end
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
                historyStates = historyStates.slice(0, historyIndex + 1);
            }
            
            // Save current state
            history.push(action);
            historyStates.push(saveCanvasState());
            historyIndex = history.length - 1;
            
            // Limit history to 20 items
            if (history.length > 20) {
                history.shift();
                historyStates.shift();
                historyIndex--;
            }
            
            updateHistoryDisplay();
            updateUndoRedoButtons();
            
            // Mark as unsaved (except for initial document creation or project load)
            if (action !== 'Document Created' && action !== 'Project Loaded' && action !== 'New Document') {
                markUnsaved();
            }
            
            // Save state to localStorage after each action
            saveEditorState();
        }

        // Update history display
        function updateHistoryDisplay() {
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';
            
            history.forEach((action, index) => {
                const item = document.createElement('div');
                item.className = 'history-item' + (index === historyIndex ? ' active' : '');
                item.textContent = action;
                item.onclick = () => restoreFromHistory(index);
                historyList.appendChild(item);
            });
            
            // Update undo/redo button states
            updateUndoRedoButtons();
        }

        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            if (undoBtn) {
                // Enable undo if we can go back
                if (historyIndex > 0) {
                    undoBtn.disabled = false;
                    undoBtn.style.opacity = '1';
                    undoBtn.style.cursor = 'pointer';
                } else {
                    undoBtn.disabled = true;
                    undoBtn.style.opacity = '0.5';
                    undoBtn.style.cursor = 'not-allowed';
                }
            }
            
            if (redoBtn) {
                // Enable redo if we can go forward
                if (historyIndex < history.length - 1) {
                    redoBtn.disabled = false;
                    redoBtn.style.opacity = '1';
                    redoBtn.style.cursor = 'pointer';
                } else {
                    redoBtn.disabled = true;
                    redoBtn.style.opacity = '0.5';
                    redoBtn.style.cursor = 'not-allowed';
                }
            }
        }

        // Restore from history
        function restoreFromHistory(index) {
            if (index >= 0 && index < historyStates.length) {
                historyIndex = index;
                const state = historyStates[index];
                
                // Restore layers
                layers = [];
                let loadedLayers = 0;
                const totalLayers = state.layers.length;
                
                state.layers.forEach((layerData, i) => {
                    const img = new Image();
                    img.onload = function() {
                        const newLayer = {
                            canvas: createLayerCanvas(),
                            name: layerData.name,
                            visible: layerData.visible,
                            opacity: layerData.opacity
                        };
                        
                        const layerCtx = newLayer.canvas.getContext('2d');
                        layerCtx.drawImage(img, 0, 0);
                        layers[i] = newLayer;
                        
                        loadedLayers++;
                        if (loadedLayers === totalLayers) {
                            currentLayer = state.currentLayer;
                            updateLayerList();
                            renderLayers();
                        }
                    };
                    img.src = layerData.imageData;
                });
                
                updateHistoryDisplay();
            }
        }

        // Undo action
        function undoAction() {
            if (historyIndex > 0) {
                restoreFromHistory(historyIndex - 1);
            }
        }

        // Redo action
        function redoAction() {
            if (historyIndex < history.length - 1) {
                restoreFromHistory(historyIndex + 1);
            }
        }

        // Layer management
        function addNewLayer() {
            const newLayer = {
                canvas: createLayerCanvas(),
                name: `Layer ${layers.length + 1}`,
                visible: true,
                opacity: 1
            };
            
            layers.push(newLayer);
            currentLayer = layers.length - 1;
            
            updateLayerList();
            addToHistory('Layer Added');
        }

        function updateLayerList() {
            const layerList = document.getElementById('layerList');
            layerList.innerHTML = '';
            
            layers.forEach((layer, index) => {
                const item = document.createElement('div');
                item.className = 'layer-item' + (index === currentLayer ? ' active' : '');
                
                item.innerHTML = `
                    <div class="layer-preview checkered"></div>
                    <div class="layer-info">
                        <div class="layer-name">${layer.name}</div>
                        <div class="layer-type">${layer.opacity < 1 ? `${Math.round(layer.opacity * 100)}% opacity` : 'Normal'}</div>
                    </div>
                    <div class="layer-controls">
                        <button class="layer-btn" onclick="toggleLayerVisibility(${index})">${layer.visible ? 'üëÅ' : 'üö´'}</button>
                        <button class="layer-btn" onclick="deleteLayer(${index})">üóë</button>
                    </div>
                `;
                
                item.onclick = () => selectLayer(index);
                layerList.appendChild(item);
            });
        }

        function selectLayer(index) {
            currentLayer = index;
            updateLayerList();
        }

        function toggleLayerVisibility(index) {
            layers[index].visible = !layers[index].visible;
            updateLayerList();
            renderLayers();
        }

        function deleteLayer(index) {
            if (layers.length > 1) {
                layers.splice(index, 1);
                if (currentLayer >= index) {
                    currentLayer = Math.max(0, currentLayer - 1);
                }
                updateLayerList();
                renderLayers();
                addToHistory('Layer Deleted');
            }
        }

        // Zoom and Pan
        function updateZoom() {
            const slider = document.getElementById('zoomSlider');
            zoom = slider.value / 100;
            
            document.getElementById('zoomDisplay').textContent = slider.value;
            document.getElementById('statusZoom').textContent = slider.value + '%';
            
            canvasWrapper.style.transform = `scale(${zoom})`;
        }

        function panCanvas(e) {
            let deltaX = 0;
            let deltaY = 0;
            
            if (e.touches && e.touches.length > 0) {
                // Touch event - calculate delta from last position
                const touch = e.touches[0];
                if (lastTouchX !== 0 || lastTouchY !== 0) {
                    deltaX = touch.clientX - lastTouchX;
                    deltaY = touch.clientY - lastTouchY;
                }
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            } else if (e.buttons === 1) {
                // Mouse event
                deltaX = e.movementX;
                deltaY = e.movementY;
            }
            
            if (deltaX !== 0 || deltaY !== 0) {
                panX += deltaX;
                panY += deltaY;
                canvasWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            }
        }

        function startPan(e) {
            panX = 0;
            panY = 0;
            if (e.touches && e.touches.length > 0) {
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else {
                lastTouchX = 0;
                lastTouchY = 0;
            }
        }

        function fitToScreen() {
            const container = document.getElementById('canvasContainer');
            const scaleX = (container.clientWidth - 40) / canvas.width;
            const scaleY = (container.clientHeight - 40) / canvas.height;
            const newZoom = Math.min(scaleX, scaleY, 1);
            
            document.getElementById('zoomSlider').value = newZoom * 100;
            updateZoom();
        }

        function actualSize() {
            document.getElementById('zoomSlider').value = 100;
            updateZoom();
        }

        // Color functions
        function updateColorFromPicker(type) {
            if (type === 'primary') {
                const input = document.getElementById('primaryColorInput');
                primaryColor = input.value;
                updatePrimaryColorSwatch(primaryColor);
            } else if (type === 'secondary') {
                const input = document.getElementById('secondaryColorInput');
                secondaryColor = input.value;
                updateSecondaryColorSwatch(secondaryColor);
            }
            // Save state after color change
            saveEditorState();
        }

        function updatePrimaryColorSwatch(color) {
            const swatch = document.getElementById('primaryColorSwatch');
            const input = document.getElementById('primaryColorInput');
            if (swatch) swatch.style.backgroundColor = color;
            if (input) input.value = color;
            primaryColor = color;
        }

        function updateSecondaryColorSwatch(color) {
            const swatch = document.getElementById('secondaryColorSwatch');
            const input = document.getElementById('secondaryColorInput');
            if (swatch) swatch.style.backgroundColor = color;
            if (input) input.value = color;
            secondaryColor = color;
        }

        // Legacy functions for compatibility
        function updateColor() {
            const input = document.getElementById('primaryColorInput');
            if (input) {
                primaryColor = input.value;
                updatePrimaryColorSwatch(primaryColor);
            }
        }

        function updateSecondaryColor() {
            const input = document.getElementById('secondaryColorInput');
            if (input) {
                secondaryColor = input.value;
                updateSecondaryColorSwatch(secondaryColor);
            }
        }

        function swapColors() {
            const temp = primaryColor;
            primaryColor = secondaryColor;
            secondaryColor = temp;
            
            updatePrimaryColorSwatch(primaryColor);
            updateSecondaryColorSwatch(secondaryColor);
            // Save state after color swap
            saveEditorState();
        }

        function resetColors() {
            primaryColor = '#000000';
            secondaryColor = '#ffffff';
            updatePrimaryColorSwatch(primaryColor);
            updateSecondaryColorSwatch(secondaryColor);
            // Save state after color reset
            saveEditorState();
        }

        function setColor(color) {
            primaryColor = color;
            updatePrimaryColorSwatch(color);
            
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.classList.remove('active');
                if (swatch.style.backgroundColor === color || swatch.style.backgroundColor === `rgb(${hexToRgb(color).r}, ${hexToRgb(color).g}, ${hexToRgb(color).b})`) {
                    swatch.classList.add('active');
                }
            });
            // Save state after color selection
            saveEditorState();
        }

        // Size and opacity controls
        function updateSize() {
            const slider = document.getElementById('sizeSlider');
            brushSize = parseInt(slider.value);
            document.getElementById('sizeDisplay').textContent = slider.value;
        }

        function updateOpacity() {
            const slider = document.getElementById('opacitySlider');
            opacity = slider.value / 100;
            document.getElementById('opacityDisplay').textContent = slider.value;
        }

        // Grid toggle
        function toggleGrid() {
            showGrid = !showGrid;
            if (showGrid) {
                drawGrid();
            } else {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            }
        }

        function drawGrid() {
            const step = 20;
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            gridCtx.strokeStyle = '#333';
            gridCtx.lineWidth = 0.5;
            
            for (let x = 0; x <= gridCanvas.width; x += step) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, gridCanvas.height);
                gridCtx.stroke();
            }
            
            for (let y = 0; y <= gridCanvas.height; y += step) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(gridCanvas.width, y);
                gridCtx.stroke();
            }
            
            gridCtx.strokeStyle = '#666';
            gridCtx.lineWidth = 1;
            
            for (let x = 0; x <= gridCanvas.width; x += step * 5) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, gridCanvas.height);
                gridCtx.stroke();
            }
            
            for (let y = 0; y <= gridCanvas.height; y += step * 5) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(gridCanvas.width, y);
                gridCtx.stroke();
            }
        }

        // Filters
        function applyFilter(type) {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            const imageData = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
            const data = imageData.data;
            
            switch (type) {
                case 'brightness':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] + 20);
                        data[i + 1] = Math.min(255, data[i + 1] + 20);
                        data[i + 2] = Math.min(255, data[i + 2] + 20);
                    }
                    break;
                    
                case 'contrast':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.max(0, Math.min(255, (data[i] - 128) * 1.2 + 128));
                        data[i + 1] = Math.max(0, Math.min(255, (data[i + 1] - 128) * 1.2 + 128));
                        data[i + 2] = Math.max(0, Math.min(255, (data[i + 2] - 128) * 1.2 + 128));
                    }
                    break;
                    
                case 'grayscale':
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        data[i] = data[i + 1] = data[i + 2] = gray;
                    }
                    break;
                    
                case 'sharpen':
                    // Simple sharpening kernel
                    const width = layer.canvas.width;
                    const height = layer.canvas.height;
                    const tempData = new Uint8ClampedArray(data);
                    
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const idx = (y * width + x) * 4;
                            
                            for (let c = 0; c < 3; c++) {
                                let sum = 0;
                                sum += tempData[idx - 4] * -1; // left
                                sum += tempData[idx + 4] * -1; // right
                                sum += tempData[idx - width * 4] * -1; // up
                                sum += tempData[idx + width * 4] * -1; // down
                                sum += tempData[idx] * 5; // center
                                
                                data[idx + c] = Math.max(0, Math.min(255, sum));
                            }
                        }
                    }
                    break;
                    
                case 'blur':
                    // Simple blur with box blur
                    const blurData = new Uint8ClampedArray(data);
                    const blurWidth = layer.canvas.width;
                    const blurHeight = layer.canvas.height;
                    
                    for (let y = 1; y < blurHeight - 1; y++) {
                        for (let x = 1; x < blurWidth - 1; x++) {
                            const idx = (y * blurWidth + x) * 4;
                            
                            for (let c = 0; c < 3; c++) {
                                let sum = 0;
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        sum += blurData[((y + dy) * blurWidth + (x + dx)) * 4 + c];
                                    }
                                }
                                data[idx + c] = sum / 9;
                            }
                            data[idx + 3] = blurData[idx + 3]; // Alpha channel
                        }
                    }
                    break;
            }
            
            layerCtx.putImageData(imageData, 0, 0);
            renderLayers();
            addToHistory(`Applied ${type} filter`);
        }

        // File operations
        function fileActions(action) {
            if (action === 'new') {
                // Create new document
                canvas.width = 800;
                canvas.height = 600;
                gridCanvas.width = canvas.width;
                gridCanvas.height = canvas.height;
                
                // Create white background layer
                const backgroundLayer = createLayerCanvas();
                const bgCtx = backgroundLayer.getContext('2d');
                bgCtx.fillStyle = '#ffffff';
                bgCtx.fillRect(0, 0, canvas.width, canvas.height);
                
                layers = [{
                    canvas: backgroundLayer,
                    name: 'Background',
                    visible: true,
                    opacity: 1
                }];
                
                currentLayer = 0;
                history = [];
                historyStates = [];
                historyIndex = -1;
                
                // Clear saved state for new document
                clearSavedState();
                
                // Reset project name
                projectName = 'Untitled';
                currentProjectPath = null;
                markSaved();
                updateProjectTitle();
                
                addToHistory('New Document');
                updateLayerList();
                renderLayers();
            } else if (action === 'open') {
                document.getElementById('fileInput').click();
            }
        }

        function loadImage(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // Resize canvas to image size
                        canvas.width = img.width;
                        canvas.height = img.height;
                        gridCanvas.width = canvas.width;
                        gridCanvas.height = canvas.height;
                        
                        // Clear layers and add image
                        layers = [{
                            canvas: createLayerCanvas(),
                            name: 'Imported Image',
                            visible: true,
                            opacity: 1
                        }];
                        
                        const layerCtx = layers[0].canvas.getContext('2d');
                        layerCtx.drawImage(img, 0, 0);
                        
                        currentLayer = 0;
                        history = [];
                        historyStates = [];
                        historyIndex = -1;
                        
                        // Clear old saved state and save new
                        clearSavedState();
                        
                        // Reset project name
                        projectName = 'Untitled';
                        currentProjectPath = null;
                        markSaved();
                        updateProjectTitle();
                        
                        addToHistory('Image Loaded');
                        updateLayerList();
                        renderLayers();
                        saveEditorState();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function exportImage() {
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');
            
            // Render all visible layers
            layers.forEach(layer => {
                if (layer.visible) {
                    exportCtx.globalAlpha = layer.opacity;
                    exportCtx.drawImage(layer.canvas, 0, 0);
                }
            });
            
            exportCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'exported_image.png';
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        function saveAsPNG() {
            const link = document.createElement('a');
            link.download = 'image.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function saveAsJPEG() {
            const link = document.createElement('a');
            link.download = 'image.jpg';
            link.href = canvas.toDataURL('image/jpeg', 0.9);
            link.click();
        }

        // Save project as .prophoto file
        function saveProject() {
            // Prompt for project name if it's "Untitled"
            let nameToSave = projectName;
            if (projectName === 'Untitled' || !projectName) {
                const userInput = prompt('Enter project name:', projectName || 'Untitled');
                if (userInput === null) {
                    // User cancelled
                    return;
                }
                nameToSave = userInput.trim() || 'Untitled';
            }
            
            // Update project name
            projectName = nameToSave;
            updateProjectTitle();
            
            try {
                // Prepare project data
                const projectData = {
                    version: '1.0',
                    timestamp: Date.now(),
                    projectName: projectName,
                    canvas: {
                        width: canvas.width,
                        height: canvas.height
                    },
                    layers: layers.map(layer => ({
                        imageData: layer.canvas.toDataURL('image/png'),
                        name: layer.name,
                        visible: layer.visible,
                        opacity: layer.opacity
                    })),
                    currentLayer: currentLayer,
                    colors: {
                        primary: primaryColor,
                        secondary: secondaryColor
                    },
                    tool: currentTool,
                    settings: {
                        brushSize: brushSize,
                        opacity: opacity,
                        zoom: zoom
                    },
                    history: history,
                    historyIndex: historyIndex,
                    historyStates: historyStates.map(state => ({
                        layers: state.layers.map(layer => ({
                            imageData: layer.imageData,
                            name: layer.name,
                            visible: layer.visible,
                            opacity: layer.opacity
                        })),
                        currentLayer: state.currentLayer
                    }))
                };

                // Convert to JSON string
                const jsonString = JSON.stringify(projectData);
                
                // Convert to Uint8Array
                const encoder = new TextEncoder();
                const dataArray = encoder.encode(jsonString);
                
                // XOR encode with a consistent key
                const key = 'ProPhotoEditor2025' + projectName;
                const encodedData = xorEncode(dataArray, key);
                
                // Create blob and download
                const blob = new Blob([encodedData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = projectName + '.prophoto';
                a.click();
                URL.revokeObjectURL(url);
                
                // Mark as saved
                markSaved();
                showNotification('Project saved successfully', 2000);
            } catch (e) {
                console.error('Error saving project:', e);
                alert('Error saving project: ' + e.message);
            }
        }

        // Load project from .prophoto file
        function loadProject() {
            document.getElementById('projectFileInput').click();
        }

        // Handle project file load
        function handleProjectLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.prophoto')) {
                alert('Invalid file format. Please select a .prophoto file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    // Read as ArrayBuffer
                    const arrayBuffer = e.target.result;
                    const dataArray = new Uint8Array(arrayBuffer);
                    
                    // Try to decode with different keys
                    const filenameWithoutExt = file.name.replace('.prophoto', '');
                    const defaultKey = 'ProPhotoEditor2025';
                    
                    // Try alternative keys
                    const alternativeKeys = [
                        defaultKey + filenameWithoutExt, // Try with filename first (most likely)
                        defaultKey + 'Untitled',         // Try with default name
                        defaultKey,                      // Try base key
                        'ProPhotoEditor'                 // Try simple key
                    ];
                    
                    let jsonString = null;
                    for (const key of alternativeKeys) {
                        try {
                            const decodedData = xorDecode(dataArray, key);
                            const decoder = new TextDecoder();
                            jsonString = decoder.decode(decodedData);
                            // Try to parse JSON to verify it's valid
                            JSON.parse(jsonString);
                            break;
                        } catch (err) {
                            // Try next key
                            continue;
                        }
                    }
                    
                    if (!jsonString) {
                        throw new Error('Could not decode project file. The file may be corrupted.');
                    }
                    
                    const projectData = JSON.parse(jsonString);
                    
                    // Restore canvas size
                    canvas.width = projectData.canvas.width;
                    canvas.height = projectData.canvas.height;
                    gridCanvas.width = canvas.width;
                    gridCanvas.height = canvas.height;
                    
                    // Restore project name
                    projectName = projectData.projectName || file.name.replace('.prophoto', '');
                    currentProjectPath = file.name;
                    
                    // Restore layers
                    layers = [];
                    let loadedLayers = 0;
                    const totalLayers = projectData.layers.length;
                    
                    if (totalLayers === 0) {
                        throw new Error('Project file contains no layers');
                    }
                    
                    projectData.layers.forEach((layerData, i) => {
                        const img = new Image();
                        img.onload = function() {
                            const newLayer = {
                                canvas: createLayerCanvas(),
                                name: layerData.name,
                                visible: layerData.visible !== undefined ? layerData.visible : true,
                                opacity: layerData.opacity !== undefined ? layerData.opacity : 1
                            };
                            
                            const layerCtx = newLayer.canvas.getContext('2d');
                            layerCtx.drawImage(img, 0, 0);
                            layers[i] = newLayer;
                            
                            loadedLayers++;
                            if (loadedLayers === totalLayers) {
                                // All layers loaded
                                currentLayer = projectData.currentLayer || 0;
                                
                                // Restore colors
                                if (projectData.colors) {
                                    primaryColor = projectData.colors.primary || '#000000';
                                    secondaryColor = projectData.colors.secondary || '#ffffff';
                                    updatePrimaryColorSwatch(primaryColor);
                                    updateSecondaryColorSwatch(secondaryColor);
                                }
                                
                                // Restore tool
                                if (projectData.tool) {
                                    selectTool(projectData.tool);
                                }
                                
                                // Restore settings
                                if (projectData.settings) {
                                    brushSize = projectData.settings.brushSize || 10;
                                    opacity = projectData.settings.opacity !== undefined ? projectData.settings.opacity : 1;
                                    zoom = projectData.settings.zoom || 1;
                                    
                                    document.getElementById('sizeSlider').value = brushSize;
                                    document.getElementById('sizeDisplay').textContent = brushSize;
                                    document.getElementById('opacitySlider').value = Math.round(opacity * 100);
                                    document.getElementById('opacityDisplay').textContent = Math.round(opacity * 100);
                                    document.getElementById('zoomSlider').value = zoom * 100;
                                    document.getElementById('zoomDisplay').textContent = Math.round(zoom * 100);
                                    document.getElementById('statusZoom').textContent = Math.round(zoom * 100) + '%';
                                    updateZoom();
                                }
                                
                                // Restore history
                                if (projectData.history && projectData.history.length > 0) {
                                    history = projectData.history;
                                    historyIndex = projectData.historyIndex !== undefined ? projectData.historyIndex : history.length - 1;
                                    
                                    if (projectData.historyStates && projectData.historyStates.length > 0) {
                                        historyStates = projectData.historyStates;
                                    }
                                } else {
                                    history = ['Project Loaded'];
                                    historyStates = [saveCanvasState()];
                                    historyIndex = 0;
                                }
                                
                                // Update UI
                                updateLayerList();
                                renderLayers();
                                updateHistoryDisplay();
                                updateProjectTitle();
                                markSaved(); // Project is saved when loaded
                                
                                showNotification('Project loaded successfully', 2000);
                            }
                        };
                        img.onerror = function() {
                            console.error('Error loading layer image');
                            loadedLayers++;
                            if (loadedLayers === totalLayers) {
                                updateLayerList();
                                renderLayers();
                                updateProjectTitle();
                            }
                        };
                        img.src = layerData.imageData;
                    });
                    
                } catch (e) {
                    console.error('Error loading project:', e);
                    alert('Error loading project: ' + e.message);
                }
            };
            reader.readAsArrayBuffer(file);
            
            // Reset file input
            event.target.value = '';
        }

        // Keyboard shortcuts
        function handleKeyDown(e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            redoAction();
                        } else {
                            undoAction();
                        }
                        break;
                    case 's':
                        e.preventDefault();
                        exportImage();
                        break;
                    case 'o':
                        e.preventDefault();
                        fileActions('open');
                        break;
                    case 'n':
                        e.preventDefault();
                        fileActions('new');
                        break;
                }
            }
        }

        // Utility functions
        function getPixelColor(data, x, y) {
            const i = (y * data.width + x) * 4;
            return [data.data[i], data.data[i + 1], data.data[i + 2], data.data[i + 3]];
        }

        function setPixelColor(data, x, y, color) {
            const i = (y * data.width + x) * 4;
            data.data[i] = color.r;
            data.data[i + 1] = color.g;
            data.data[i + 2] = color.b;
            data.data[i + 3] = 255;
        }

        function colorsMatch(color1, color2, tolerance = 0) {
            return Math.abs(color1[0] - color2[0]) <= tolerance &&
                   Math.abs(color1[1] - color2[1]) <= tolerance &&
                   Math.abs(color1[2] - color2[2]) <= tolerance &&
                   Math.abs(color1[3] - color2[3]) <= tolerance;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Selection display
        function updateSelectionDisplay() {
            if (selectedArea) {
                // This would draw selection outlines
                // For now, just update the status
            }
        }

        // Dropdown menu functions
        function toggleDropdown(menuId) {
            const menu = document.getElementById(menuId);
            const isShown = menu.classList.contains('show');
            
            // Hide all dropdowns first
            hideAllDropdowns();
            
            // Toggle the clicked menu
            if (!isShown) {
                menu.classList.add('show');
            }
        }

        function hideAllDropdowns() {
            document.querySelectorAll('.dropdown-menu').forEach(menu => {
                menu.classList.remove('show');
            });
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.menu-item')) {
                hideAllDropdowns();
            }
        });

        // Additional menu functions
        function clearCanvas() {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            layerCtx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
            renderLayers();
            addToHistory('Canvas Cleared');
        }

        function zoomIn() {
            const slider = document.getElementById('zoomSlider');
            const newValue = Math.min(500, parseInt(slider.value) + 10);
            slider.value = newValue;
            updateZoom();
        }

        function zoomOut() {
            const slider = document.getElementById('zoomSlider');
            const newValue = Math.max(10, parseInt(slider.value) - 10);
            slider.value = newValue;
            updateZoom();
        }

        function invertColors() {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            const imageData = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];         // Red
                data[i + 1] = 255 - data[i + 1]; // Green
                data[i + 2] = 255 - data[i + 2]; // Blue
            }
            
            layerCtx.putImageData(imageData, 0, 0);
            renderLayers();
            addToHistory('Inverted Colors');
        }

        function applySepia() {
            const layer = layers[currentLayer];
            const layerCtx = layer.canvas.getContext('2d');
            const imageData = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
            }
            
            layerCtx.putImageData(imageData, 0, 0);
            renderLayers();
            addToHistory('Applied Sepia');
        }

        function duplicateCurrentLayer() {
            if (layers.length > 0) {
                const currentLayerData = layers[currentLayer];
                const newLayer = {
                    canvas: createLayerCanvas(),
                    name: `${currentLayerData.name} Copy`,
                    visible: true,
                    opacity: currentLayerData.opacity
                };
                
                // Copy the content
                const newCtx = newLayer.canvas.getContext('2d');
                newCtx.drawImage(currentLayerData.canvas, 0, 0);
                
                layers.push(newLayer);
                currentLayer = layers.length - 1;
                
                updateLayerList();
                addToHistory('Layer Duplicated');
            }
        }

        function deleteCurrentLayer() {
            if (layers.length > 1) {
                layers.splice(currentLayer, 1);
                currentLayer = Math.max(0, currentLayer - 1);
                updateLayerList();
                renderLayers();
                addToHistory('Layer Deleted');
            } else {
                alert('Cannot delete the last layer!');
            }
        }

        function mergeDown() {
            if (currentLayer > 0) {
                const upperLayer = layers[currentLayer];
                const lowerLayer = layers[currentLayer - 1];
                
                const lowerCtx = lowerLayer.canvas.getContext('2d');
                lowerCtx.globalAlpha = upperLayer.opacity;
                lowerCtx.drawImage(upperLayer.canvas, 0, 0);
                lowerCtx.globalAlpha = 1;
                
                layers.splice(currentLayer, 1);
                currentLayer--;
                
                updateLayerList();
                renderLayers();
                addToHistory('Layers Merged');
            } else {
                alert('Cannot merge down from the bottom layer!');
            }
        }

        function flattenImage() {
            if (layers.length > 1) {
                const flattenedCanvas = createLayerCanvas();
                const flattenedCtx = flattenedCanvas.getContext('2d');
                
                // Render all visible layers onto the flattened canvas
                layers.forEach(layer => {
                    if (layer.visible) {
                        flattenedCtx.globalAlpha = layer.opacity;
                        flattenedCtx.drawImage(layer.canvas, 0, 0);
                    }
                });
                
                layers = [{
                    canvas: flattenedCanvas,
                    name: 'Background',
                    visible: true,
                    opacity: 1
                }];
                
                currentLayer = 0;
                updateLayerList();
                renderLayers();
                addToHistory('Image Flattened');
            }
        }

        // About modal functions
        function showAbout() {
            const modal = document.getElementById('aboutModal');
            modal.classList.add('show');
        }

        function closeAboutModal(event) {
            const modal = document.getElementById('aboutModal');
            if (!event || event.target === modal) {
                modal.classList.remove('show');
            }
        }

        // Show changelog modal
        function showChangelog() {
            const modal = document.getElementById('changelogModal');
            const content = document.getElementById('changelogContent');
            
            // Show modal (remove inline style to allow CSS class to work)
            modal.style.display = '';
            modal.classList.add('show');
            
            // Load changelog content
            loadChangelog(content);
        }

        // Close changelog modal
        function closeChangelogModal(event) {
            const modal = document.getElementById('changelogModal');
            if (!event || event.target === modal) {
                modal.classList.remove('show');
                modal.style.display = 'none';
            }
        }

        // Load and parse changelog from CHANGELOG.md
        function loadChangelog(contentElement) {
            fetch('CHANGELOG.md')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to load changelog');
                    }
                    return response.text();
                })
                .then(text => {
                    const html = parseChangelogMarkdown(text);
                    contentElement.innerHTML = html;
                })
                .catch(error => {
                    console.error('Error loading changelog:', error);
                    contentElement.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #ff6b6b;">
                            <p>Error loading changelog.</p>
                            <p style="font-size: 12px; margin-top: 8px;">${error.message}</p>
                        </div>
                    `;
                });
        }

        // Parse markdown changelog to HTML
        function parseChangelogMarkdown(markdown) {
            let html = '';
            const lines = markdown.split('\n');
            let inVersionSection = false;
            let inList = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Skip empty lines at the start
                if (!line && !html) continue;
                
                // Version headers [x.x.x] - Date
                if (line.match(/^## \[[\d.]+\]/)) {
                    if (inList) {
                        html += '</ul>';
                        inList = false;
                    }
                    if (inVersionSection) {
                        html += '</div>';
                    }
                    const versionMatch = line.match(/\[([\d.]+)\]/);
                    const dateMatch = line.match(/- (\d{4}-\d{2}-\d{2})/);
                    const version = versionMatch ? versionMatch[1] : '';
                    const date = dateMatch ? dateMatch[1] : '';
                    
                    html += `<div class="version-section">`;
                    html += `<h2>Version ${version}${date ? ` <span style="color: #888; font-size: 14px;">(${date})</span>` : ''}</h2>`;
                    inVersionSection = true;
                    continue;
                }
                
                // Subsection headers (### Added, ### Changed, etc.)
                if (line.match(/^### (Added|Changed|Deprecated|Removed|Fixed|Security|Technical)$/)) {
                    if (inList) {
                        html += '</ul>';
                        inList = false;
                    }
                    const section = line.replace('### ', '');
                    html += `<h3>${section}</h3>`;
                    continue;
                }
                
                // Bullet points
                if (line.startsWith('- **') || line.startsWith('- ')) {
                    if (!inList) {
                        html += '<ul>';
                        inList = true;
                    }
                    let item = line.replace(/^-\s*/, '');
                    // Convert **bold** to <strong>
                    item = item.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    // Convert `code` to <code>
                    item = item.replace(/`([^`]+)`/g, '<code>$1</code>');
                    // Convert links [text](url) to <a>
                    item = item.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
                    html += `<li>${item}</li>`;
                    continue;
                }
                
                // Close list if we hit a non-list line
                if (inList && line && !line.startsWith('-')) {
                    html += '</ul>';
                    inList = false;
                }
                
                // Regular paragraphs
                if (line && !line.startsWith('#') && !line.startsWith('---') && !line.match(/^\[[\d.]+\]/)) {
                    let para = line;
                    // Convert **bold** to <strong>
                    para = para.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    // Convert `code` to <code>
                    para = para.replace(/`([^`]+)`/g, '<code>$1</code>');
                    // Convert links [text](url) to <a>
                    para = para.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
                    html += `<p>${para}</p>`;
                    continue;
                }
                
                // Horizontal rules
                if (line.startsWith('---')) {
                    if (inList) {
                        html += '</ul>';
                        inList = false;
                    }
                    html += '<hr style="border: none; border-top: 1px solid #555; margin: 20px 0;">';
                    continue;
                }
            }
            
            // Close any open tags
            if (inList) {
                html += '</ul>';
            }
            if (inVersionSection) {
                html += '</div>';
            }
            
            return html || '<p style="color: #888;">No changelog content available.</p>';
        }

        // Close modal with ESC key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const restoreDialog = document.getElementById('restoreDialog');
                const changelogModal = document.getElementById('changelogModal');
                const aboutModal = document.getElementById('aboutModal');
                
                if (restoreDialog && restoreDialog.classList.contains('show')) {
                    // ESC on restore dialog starts new session
                    startNewSession();
                } else if (changelogModal && changelogModal.classList.contains('show')) {
                    // ESC on changelog modal closes it
                    closeChangelogModal();
                } else if (aboutModal && aboutModal.classList.contains('show')) {
                    // ESC on about modal closes it
                    closeAboutModal();
                }
            }
        });

        // Initialize the editor when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>